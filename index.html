<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1">

<script>
//collection - product -piece

materialsArr = {
  "materials": [
    {
      "name": "UV_map",
      "type": "single",
      "texture": "textures/uv_grid_opengl.jpg"
    },
    {
      "name": "glass1",
      "type": "glass1"
    },
    {
      "name": "glass2",
      "type": "glass2"
    },
    {
      "name": "UV_6map",
      "type": "array",
      "texture1": "textures/uv_grid_opengl.jpg",
      "texture2": "textures/uv_grid_opengl.jpg",
      "texture3": "textures/uv_grid_opengl.jpg",
      "texture4": "textures/uv_grid_opengl.jpg",
      "texture5": "textures/uv_grid_opengl.jpg",
      "texture6": "textures/uv_grid_opengl.jpg"
    },
    {
      "name": "dice",
      "type": "array",
      "texture1": "images/Dice-Blue-1.png",
      "texture2": "images/Dice-Blue-2.png",
      "texture3": "images/Dice-Blue-3.png",
      "texture4": "images/Dice-Blue-4.png",
      "texture5": "images/Dice-Blue-5.png",
      "texture6": "images/Dice-Blue-6.png"
    },
    {
      "name": "dice2",
      "type": "array",
      "texture1": "images/Dice-Blue-1.png",
      "texture2": "images/Dice-Blue-2.png",
      "texture3": "images/Dice-Blue-3.png",
      "texture4": "images/Dice-Blue-4.png",
      "texture5": "images/Dice-Blue-5.png",
      "texture6": "images/Dice-Blue-6.png"
    },
    {
      "name": "plywood6",
      "type": "array",
      "texture1": "textures/plywood_diff_1k.jpg",
      "texture2": "textures/plywood_diff_1k.jpg",
      "texture3": "textures/plywood_diff_1k.jpg",
      "texture4": "textures/plywood_diff_1k.jpg",
      "texture5": "textures/plywood_diff_1k.jpg",
      "texture6": "textures/plywood_diff_1k.jpg"
    },
    {
      "name": "plywood",
      "type": "single",
      "texture": "textures/plywood_diff_1k.jpg"
    },
    {
      "name": "kitchen_wood",
      "type": "single",
      "texture": "textures/kitchen_wood_diff_1k.jpg"
    },
    {
      "name": "wood_table",
      "type": "single",
      "texture": "textures/wood_table_001_diff_1k.jpg"
    }
  ]
}

materialOptionsObj = {
  "materialOptions": [
    {
      "name": "materials ext",
      "materials": [
        {"material": "plywood6"},
        {"material": "wood_table"},
        {"material": "kitchen_wood"},
        {"material": "UV_6map"},
        {"material": "dice"}
      ]
    }
  ]
}

collection = {};

function saveFileAs() {
    exportCollection();
    // https://codepen.io/mmousawy/pen/wBbrKM?editors=1010
    var promptFilename = "collection.txt" 
        var textBlob = new Blob([document.getElementById("jsonObj").value],
          {type:'text/plain'});
        var downloadLink = document.createElement("a");
        downloadLink.download = promptFilename;
        downloadLink.innerHTML = "Download File";
        downloadLink.href = window.URL.createObjectURL(textBlob);
        downloadLink.click();
    delete downloadLink;
    delete textBlob;
}

function readFile() {
    //https://cssdeck.com/labs/7bx7mmcm
    var fileToLoad = document.getElementById("loadFile").files[0];

    var fileReader = new FileReader();
    fileReader.onload = function(fileLoadedEvent) 
    {
        var textFromFileLoaded = fileLoadedEvent.target.result;
        document.getElementById("jsonObj").value = textFromFileLoaded;
        designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
        init();
    };
    fileReader.readAsText(fileToLoad, "UTF-8");
}

function loadJSON() {
    designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
    init();
}

</script>

<div id='renderDiv'></div>
<div id='modelDiv'></div>
<br>
<button onclick="saveFileAs()">Save to file</button>
<input id="loadFile" type="file"/>
<button onclick="readFile()">Read file</button>
<br>
<textarea ROWS=1 COLS=1 id='jsonObj'>
{"materialsArr":{},"designArr":{"init":{"name":"init","parameters":[],"pieces":[]},"components":{"name":"components","parameters":[{"name":"lx","type":"cm","min":"0","max":"200","step":"1","default":"100"},{"name":"ly","type":"cm","min":"0","max":"200","step":"1","default":"100"},{"name":"lz","type":"cm","min":"0","max":"200","step":"1","default":"100"},{"name":"rx","type":"m","min":"0","max":"400","step":"1","default":"0"},{"name":"ry","type":"m","min":"0","max":"400","step":"1","default":"0"},{"name":"rz","type":"m","min":"0","max":"400","step":".5","default":"0"},{"name":"x","type":"cm","min":"-300","max":"400","step":"1","default":"0"},{"name":"y","type":"cm","min":"-100","max":"400","step":"1","default":"0"},{"name":"z","type":"cm","min":"-100","max":"400","step":".5","default":"0"},{"name":"sx","type":"m","min":".1","max":"10","step":".1","default":"1"},{"name":"sy","type":"m","min":".1","max":"10","step":".1","default":"1"},{"name":"sz","type":"m","min":".1","max":"10","step":".1","default":"1"}],"pieces":[{"name":"cilindro","type":"Cylinder","rt":"lx/2","rb":"ly/2","lz":"lz","material":"plywood6","sx":"sx","sy":"sy","sz":"sz","rx":"90 + rx","ry":"ry","rz":"rz","x":"x","y":"y","z":"z + lz/2"},{"name":"cubo","type":"Box","lx":"lx","ly":"ly","lz":"lz","material":"dice","sx":"sx","sy":"sy","sz":"sz","rx":"rx","ry":"ry","rz":"rz","x":"x + 1","y":"y","z":"z"},{"name":"triangle","type":"Triangle","b":"lx","h":"ly","d":"0.3","lz":"lz","material":"plywood6","sx":"sx","sy":"sy","sz":"sz","rx":"rx","ry":"ry","rz":"rz","x":"2.4+x","y":"y","z":"z"},{"name":"prisma","type":"Extrude","shape_array":[["0","0"],["lx","0"],["0.8","ly"],[".2","1"]],"lz":"lz","material":"plywood6","sx":"sx","sy":"sy","sz":"sz","rx":"rx","ry":"ry","rz":"rz","x":"-2","y":"y","z":"z"}]},"cajon_curva":{"name":"cajon_curva","parameters":[{"name":"largo","type":"cm","min":10,"max":400,"default":40},{"name":"alto","type":"cm","min":10,"max":100,"default":20},{"name":"profundidad","type":"cm","min":10,"max":120,"default":30},{"name":"espesor","type":"cm","min":0.5,"max":12,"default":2},{"name":"rebaje_largo","type":"cm","min":"0.5","max":"20","default":"10"},{"name":"rebaje_alto","type":"cm","min":"0.5","max":"10","step":".2","default":"2"}],"pieces":[{"name":"lado derecho","type":"Box","lx":"espesor","ly":"profundidad - espesor","lz":"alto-espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":0,"y":0,"z":"espesor"},{"name":"lado izquierdo","type":"Box","lx":"espesor","ly":"profundidad - espesor","lz":"alto-espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"largo-espesor","y":0,"z":"espesor"},{"name":"base","type":"Box","lx":"largo","ly":"profundidad - espesor","lz":"espesor","material":"kitchen_wood","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"0","y":0,"z":0},{"name":"fondo","type":"Box","lx":"largo - espesor * 2","ly":"espesor","lz":"alto-espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"espesor","y":0,"z":"espesor"},{"name":"frente","type":"Extrude","shape_array":[["0","0"],["largo","0"],["largo","alto"],["largo-((largo-0.12-rebaje_largo)/2)","alto"],["largo-((largo-0.12-rebaje_largo)/2)-0.06","alto-rebaje_alto","largo-((largo-0.12-rebaje_largo)/2)-0.04","alto","largo-((largo-0.12-rebaje_largo)/2)-0.02","alto-rebaje_alto"],["((largo-0.12-rebaje_largo)/2)+0.06","alto-rebaje_alto"],["((largo-0.12-rebaje_largo)/2)","alto","((largo-0.12-rebaje_largo)/2)+0.02","alto-rebaje_alto","((largo-0.12-rebaje_largo)/2)+0.04","alto"],["0","alto"]],"lz":"espesor","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"90","ry":"0","rz":"0","x":"0","y":"profundidad","z":"0"},{"name":"tirador","type":"Box","lx":"largo/10","ly":"espesor","lz":"alto/10","material":"kitchen_wood","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"largo/2-largo/10/2","y":"profundidad","z":"alto/2"}]},"cajonera":{"name":"cajonera","parameters":[{"name":"largo","type":"cm","min":20,"max":400,"default":100},{"name":"alto","type":"cm","min":40,"max":250,"default":200},{"name":"profundidad","type":"cm","min":20,"max":200,"default":100},{"name":"espesor","type":"cm","min":0.5,"max":12,"default":2},{"name":"espaciado","type":"cm","min":0,"max":10,"default":1},{"name":"cajones","type":"m","min":0,"max":20,"default":2},{"name":"tiempo","type":"m","min":0,"max":100,"default":0}],"pieces":[{"name":"cajon","type":"Module","subsystem":"cajon_curva","parameters":[{"name":"largo","default":"largo"},{"name":"alto","default":"(alto-espaciado*(cajones-1))/cajones"},{"name":"espesor","default":"espesor"},{"name":"profundidad","default":"profundidad"},{"name":"rebaje_largo","default":"largo/3"},{"name":"rebaje_alto","default":"(alto-espaciado*(cajones-1))/cajones/3"}],"material":"dice","array_size":"cajones","sx":1,"sy":1,"sz":1,"rx":"0","ry":"0","rz":"0","x":"0","y":"ramp(array_i*10,array_i*10+25,100+array_i*10,100+array_i*10+25,tiempo)*profundidad*0.8","z":"array_i*(alto-espaciado*(cajones-1))/cajones+array_i*espaciado"}]},"marco":{"name":"marco","parameters":[{"name":"largo","type":"cm","min":10,"max":400,"default":40},{"name":"alto","type":"cm","min":10,"max":100,"default":20},{"name":"profundidad","type":"cm","min":"1","max":"10","step":".2","default":"2"},{"name":"espesor","type":"cm","min":0.5,"max":12,"default":2}],"pieces":[{"name":"lado derecho","type":"Box","lx":"espesor","ly":"profundidad","lz":"alto","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"0","y":"0","z":"0"},{"name":"lado izquierdo","type":"Box","lx":"espesor","ly":"profundidad","lz":"alto","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"largo-espesor","y":"0","z":"0"},{"name":"base","type":"Box","lx":"largo-espesor*2","ly":"profundidad","lz":"espesor","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"espesor","y":"0","z":"0"},{"name":"alto","type":"Box","lx":"largo - espesor * 2","ly":"profundidad","lz":"espesor","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"espesor","y":"0","z":"alto-espesor"},{"name":"panel","type":"Box","lx":"largo-espesor","ly":"profundidad/2","lz":"alto-espesor","material":"glass2","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"espesor/2","y":"profundidad/2","z":"espesor/2"},{"name":"tirador","type":"Box","lx":"espesor/2","ly":".015","lz":"0.03","material":"kitchen_wood","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"0","x":"largo-espesor*.75","y":"profundidad","z":"alto/2"}]},"armario":{"name":"armario","parameters":[{"name":"largo_m1","type":"cm","min":20,"max":400,"default":60},{"name":"largo_modulo_cajones","type":"cm","min":20,"max":400,"default":60},{"name":"alto","type":"cm","min":40,"max":250,"default":180},{"name":"profundidad","type":"cm","min":20,"max":120,"default":60},{"name":"espesor","type":"cm","min":1,"max":12,"default":4},{"name":"espesor_cajon","type":"cm","min":1,"max":12,"default":2},{"name":"balda1","type":"cm","min":0,"max":200,"default":30},{"name":"balda_caj","type":"cm","min":0,"max":200,"default":0},{"name":"altura_cajonera","type":"m","min":0,"max":100,"default":60},{"name":"espaciado_vert","type":"cm","min":0,"max":10,"default":1},{"name":"espaciado_hor","type":"cm","min":0,"max":10,"default":1},{"name":"modulos","type":"m","min":0,"max":10,"default":3},{"name":"cajones","type":"m","min":0,"max":20,"default":6},{"name":"tiempo","type":"m","min":0,"max":300,"default":0}],"pieces":[{"name":"objeto gltf","type":"Gltf","url":"models/legoCube/scene.gltf","material":"plywood6","sx":".1","sy":".1","sz":".1","rx":"90","ry":"0","rz":"0","x":"largo_m1*0.3","y":"profundidad/2","z":"balda1+espesor+0.0215"},{"name":"lado derecho","type":"Box","lx":"espesor","ly":"profundidad","lz":"alto-espesor*2","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":0,"y":0,"z":"espesor"},{"name":"lado izquierdo","type":"Box","lx":"espesor","ly":"profundidad","lz":"alto-espesor*2","material":"plywood6","array_size":"modulos","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"largo_m1 + largo_modulo_cajones * (array_i + 1)-espesor","y":0,"z":"espesor"},{"name":"centro","type":"Box","lx":"espesor","ly":"profundidad","lz":"alto-espesor*2","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"largo_m1-espesor","y":0,"z":"espesor"},{"name":"base","type":"Box","lx":"largo_m1 + largo_modulo_cajones * modulos","ly":"profundidad","lz":"espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"0","y":0,"z":0},{"name":"tapa","type":"Box","lx":"largo_m1 + largo_modulo_cajones * modulos","ly":"profundidad","lz":"espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"0","y":"0","z":"alto-espesor"},{"name":"fondo","type":"Box","lx":"largo_m1 + largo_modulo_cajones * modulos","ly":"espesor","lz":"alto","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"0","y":"-espesor","z":"0"},{"name":"balda","type":"Box","lx":"largo_m1-espesor*2","ly":"profundidad","lz":"espesor","material":"plywood6","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"espesor","y":0,"z":"balda1"},{"name":"balda cajones","type":"Box","lx":"largo_modulo_cajones-espesor","ly":"profundidad","lz":"espesor","material":"plywood6","array_size":"modulos","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"largo_m1 + array_i*(largo_modulo_cajones)","y":0,"z":"(alto - 2*espesor)*altura_cajonera/100 + + espesor + espaciado_vert + balda_caj"},{"name":"cajoneras","type":"Module","subsystem":"cajonera","parameters":[{"name":"largo","default":"largo_modulo_cajones - espesor - espaciado_hor*2"},{"name":"alto","default":"(alto - 2*espesor)*altura_cajonera/100"},{"name":"profundidad","default":"profundidad - espesor"},{"name":"espaciado","default":"espaciado_vert"},{"name":"espesor","default":"espesor_cajon"},{"name":"cajones","default":"cajones"},{"name":"tiempo","default":"tiempo"}],"material":"plywood6","array_size":"modulos","sx":1,"sy":1,"sz":1,"rx":0,"ry":0,"rz":0,"x":"largo_m1+array_i*(largo_modulo_cajones)+espaciado_hor","y":"0","z":"espesor"},{"name":"puerta","type":"Module","subsystem":"marco","parameters":[{"name":"largo","default":"largo_m1"},{"name":"alto","default":"alto-espesor"},{"name":"profundidad","default":"espesor"},{"name":"espesor","default":"espesor*3"}],"material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"0","ry":"0","rz":"ramp(0,50,100,150,tiempo)*120","x":"0","y":"profundidad","z":"0"},{"name":"barra","type":"Cylinder","rt":"espesor/2","rb":"espesor/2","lz":"largo_m1 + largo_modulo_cajones * modulos","material":"plywood6","sx":"1","sy":"1","sz":"1","rx":"90","ry":"90","rz":"0","x":"(largo_m1 + largo_modulo_cajones * modulos)/2","y":"profundidad","z":"alto-espesor/2"}]}}}
</textarea>
<br>
<button onclick="exportCollection()">Show JSON</button><a href='https://codebeautify.org/jsonviewer'>See JSON beautify</a><button onclick="loadJSON()">Load JSON</button>

<script>
designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;

//const objectName = window.location.hash.substring( 1 ) || 'armario';
const objectName = window.location.search.substring( 1 ) || 'armario';
designObj = designArr[objectName];

materialsObj = materialsArr;

loaders = {};

function ramp(a,b,c,d,t) {
  //  1               --------
  //                 /        \
  //                /          \
  //               /            \
  //  0 -----------              -----------
  //              a   b      c   d          
  
  if (t <= a) return 0;
  else if (t <= b) return (t - a)/(b-a);
  else if (t < c) return 1;
  else if (t <= d) return 1 - (t - c)/(d-c);
  else return 0;
}
</script>


  <style id="compiled-css" type="text/css">
      body {
      margin: 0;
}
    /* EOS */
  </style>

  <script id="insert"></script>


</head>
<body>
    
<script type="importmap">
    {
        "imports": {
            "three": "./three/build/three.module.js"
        }
    }
</script>

<script type="module">//<![CDATA[


    import * as THREE from 'three';

    import { GUI } from './jsm/libs/lil-gui.module.min.js';
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

    loaders.GLTFLoader = GLTFLoader;


    let mesh, renderer, scene, camera;

    let gui;

    var API = {
        offsetX: 0,
        offsetY: 0,
        repeatX: 1.,
        repeatY: 1.,
        rotation: 0,  //Math.PI / 4, // positive is counter-clockwise
        centerX: 0.0,
        centerY: 0.0,
        price: 10,
        renders: 0,
    };
    const settings = {
        debug: false,
        axes: true,
        UV: false,
    };
    var geometry;
    var material_UV;
    var materialArray;
    var axesHelper;
    var evalText;
    var guiPieces = null;

    /*
    */
    init();
    showForm();
    
    export function init() {

        for (var i =0; i< designObj.parameters.length; i++) {
            API[designObj.parameters[i].name] = Number(designObj.parameters[i].default);
        }

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        var divEl = document.getElementById("renderDiv");
        if (divEl == null) {  // create node or delete content node
            divEl = document.createElement("DIV");
            divEl.setAttribute("id", "renderDiv");
            document.appendChild( divEl);
        } else {
            divEl.textContent = ''
        }
        divEl.appendChild( renderer.domElement );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, .1, 1000 );
        camera.position.set( 2, 3, 1.6 );
        camera.up.set(0,0,1)   // z up (https://stackoverflow.com/questions/44630265/how-can-i-set-z-up-coordinate-system-in-three-js)
        scene.add( camera );

        const controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render );
        controls.minDistance = 1;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 * 1.5;


        const light = new THREE.DirectionalLight( 0xffffff, .8 );
        light.position.x = 5;
        light.position.y = 6;
        light.position.z = 7;
        scene.add( light );
        const light2 = new THREE.DirectionalLight( 0xffffff, .8 );
        light2.position.x = -2;
        light2.position.y = 2;
        light2.position.z = .5;
        scene.add( light2 );
        const light3 = new THREE.DirectionalLight( 0xffffff, .8 );
        light3.position.x = .5;
        light3.position.y = .5;
        light3.position.z = -.5;
        scene.add( light3 );
        const light4 = new THREE.DirectionalLight( 0xffffff, 1.3 );
        light4.position.x = -2;
        light4.position.y = -2;
        light4.position.z = .5;
        scene.add( light4 );
        //const helper = new THREE.DirectionalLightHelper( light4, 5 );
        //scene.add( helper );
        
        for (var i =0; i< materialsObj.materials.length; i++) {
            console.log("Material: " + materialsObj.materials[i].name);
            if (materialsObj.materials[i].type == "single") {
                var texture = new THREE.TextureLoader().load( materialsObj.materials[i].texture, function ( texture ) {
                    render();
                } );
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually
                //var meshMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture } );
                var meshMaterial = new THREE.MeshStandardMaterial( { map: texture });
                //var meshMaterial = new THREE.MeshBasicMaterial( { map: texture } );
                //material_UV = material;  // tmp
                materialsObj.materials[i].material = meshMaterial;
            } else if (materialsObj.materials[i].type == "glass1") {
                  const meshMaterial = new THREE.MeshPhysicalMaterial( {
					map: null,
					color: 0xffffff,
					metalness: 0,
					roughness: 0,
					opacity: 0.25,
					side: THREE.BackSide,
					transparent: true,
					envMapIntensity: 10,
					premultipliedAlpha: true
				} );
                materialsObj.materials[i].material = meshMaterial;
            } else if (materialsObj.materials[i].type == "glass2") {
                var meshMaterial = new THREE.MeshPhysicalMaterial({
                    metalness: .9,
                    roughness: .05,
                    envMapIntensity: 0.9,
                    clearcoat: 1,
                    transparent: true,
                    // transmission: .95,
                    opacity: .5,
                    reflectivity: 0.2,
                    refractionRatio: 0.985,
                    ior: 0.9,
                    side: THREE.BackSide,
                    })
                materialsObj.materials[i].material = meshMaterial;
            } else {  // array
                materialArray = [];
                texture = loadTexture(materialsObj.materials[i].texture1);
                texture = loadTexture(materialsObj.materials[i].texture2);
                texture = loadTexture(materialsObj.materials[i].texture3);
                texture = loadTexture(materialsObj.materials[i].texture4);
                texture = loadTexture(materialsObj.materials[i].texture5);
                texture = loadTexture(materialsObj.materials[i].texture6);
                materialsObj.materials[i].material = materialArray;
            }
            if (materialsObj.materials[i].name == "UV_6map") {
                material_UV = materialArray;
            }
        }

//        addDesign(scene, designObj);
        
        axesHelper = new THREE.AxesHelper( 4 );
        axes();
        scene.add( axesHelper );
        

        updateMeasures();  // comment to improve speed while working in html forms
        updateUvTransform();
        
        initGui();
        //printModelTable("model", designObj);
        showForm();

        render();

        window.addEventListener( 'resize', onWindowResize );

    }

    //import { init } from ".";
    window.init = init;
    window.updateMeasures = updateMeasures;
    


    function showForm() {
        var modelDiv = document.getElementById('modelDiv')
        modelDiv.textContent = ''
    
        for (var prop in designArr) {
            if (Object.prototype.hasOwnProperty.call(designArr, prop)) {
                printModelTable(designArr[prop].name, designArr[prop]);
            }
        }
    }
    function visibility(arg) {
        console.log("visibility: " + arg + " " + this.property);
        //getPiece(this.property).array[0].mesh.visible = arg;
        API[this.property + 'array_index'].mesh.visible = arg;
        render();
    }
    /*function createSimplePoint(THREE) {
        var geometry = new THREE.BufferGeometry();
        const vertices = [];
        vertices.push(new THREE.Vector3( 0, 0, 0));
        //geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
        var dot = new THREE.Points(geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );
        return dot;
    }
    */
    function loadTexture(file) {
    
    
        var texture = new THREE.TextureLoader().load( file,function (º) {
            //meshMaterial.needsUpdate = true;
            render();
        } )
        //var meshMaterial = new THREE.MeshBasicMaterial( { map: texture });
        //var meshMaterial = new THREE.MeshStandardMaterial( { map: texture });
        var meshMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture } );
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture.matrixAutoUpdate = false;
        materialArray.push(meshMaterial);
        return texture;
    }

    function updateMeasures(){
        evalText = "";
        for (var i =0; i< designObj.parameters.length; i++) {
            if (designObj.parameters[i].type == "m") {
                evalText = evalText + designObj.parameters[i].name + "=" + Number(API[designObj.parameters[i].name]) + ";";
            } else {  // cm
                evalText = evalText + designObj.parameters[i].name + "=" + Number(API[designObj.parameters[i].name])/100 + ";";
            }
        }
        //designObj.eval = makeEvalContext ("var context='main';" + evalText);
        designObj.evalText = "var context='main';" + evalText;
        updateMeasuresAPI(scene, THREE, API, designObj);
        updateUvTransform();
        render();
        if (gui != null) {
            API.renders ++;
            //API.price = Math.round(eval('alto*largo*200'));

                for (var j = 0; j < gui.controllers.length; j++ ) {
                    gui.controllers[j].updateDisplay();
                }
/*
            for (var i = 0; i < Object.keys(gui.folders).length; i++) {
                var key = Object.keys(gui.folders)[i];
                for (var j = 0; j < gui.folders[key].controllers.length; j++ )
                {
                    gui.folders[key].controllers[j].updateDisplay();
                }
            }
*/
        }
    }

    function updateMaterial(){
        updateMaterialDesign(designObj);
        render();
    }
    function updateMaterialDesign(updateMaterialDesignObj){
        console.log("updateMaterial");
        for (var i =0; i< materialOptionsObj.materialOptions.length; i++) {
            console.log(API[materialOptionsObj.materialOptions[i].name]);
        }
        for (var i = 0; i< updateMaterialDesignObj.pieces.length; i++) {
            if ('subsystem' in updateMaterialDesignObj.pieces[i]) {
                updateMaterialDesign(designArr[updateMaterialDesignObj.pieces[i].subsystem])
            } else {
                updateMaterialDesignObj.pieces[i].array[0].mesh.material=getMaterial(API[materialOptionsObj.materialOptions[0].name]).material;
            }
        }
        return; 
    }
    


    function render() {
        renderer.render( scene, camera );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

    }

    

    function debug() {
        console.debug("debug: " + settings.debug);
        debugger;
    }
    function axes(arg) {
        console.debug("axes: " + settings.axes);
        console.debug("axes arg: " + arg);
        axesHelper.visible = settings.axes;
        render();
    }
    function setUV() {
        console.debug("setUV: " + settings.UV);
        setUVSubsystem(designObj);
        render();
    }
    function setUVSubsystem(designSubsystem) {
        if (settings.UV) {
            for (var i = 0; i< designSubsystem.pieces.length; i++) {
                for (var array_i = 0; array_i < designSubsystem.pieces[i].array.length ; array_i++) {
                    designSubsystem.pieces[i].array[array_i].mesh.materialOriginal = designSubsystem.pieces[i].array[array_i].mesh.material;
                    designSubsystem.pieces[i].array[array_i].mesh.material=material_UV;
                    if ('subsystem' in designSubsystem.pieces[i]) {
                        setUVSubsystem(designSubsystem.pieces[i].array[array_i].subsystemDesign);
                    }
                }
            }
        } else {
            for (var i = 0; i< designSubsystem.pieces.length; i++) {
                for (var array_i = 0; array_i < designSubsystem.pieces[i].array.length ; array_i++) {
                    designSubsystem.pieces[i].array[array_i].mesh.material = designSubsystem.pieces[i].array[array_i].mesh.materialOriginal;
                    if ('subsystem' in designSubsystem.pieces[i]) {
                        setUVSubsystem(designSubsystem.pieces[i].array[array_i].subsystemDesign);
                    }
                }
            }
//                    designSubsystem.pieces[0].mesh.material=materialArray;
        }
    }
    function initGui() {

        if (gui != null) gui.destroy();  // if previous GUI exists
        gui = new GUI();

        for (var i =0; i< designObj.parameters.length; i++) {
            gui.add( API, designObj.parameters[i].name, Number(designObj.parameters[i].min), Number(designObj.parameters[i].max)).step(Number(designObj.parameters[i].step) || 1).name( designObj.parameters[i].name ).onChange( updateMeasures);
        }
        
        if (materialOptionsObj.materialOptions != null) {
            for (var i =0; i< materialOptionsObj.materialOptions.length; i++) {
                var materialOption = materialOptionsObj.materialOptions[i];
                console.log("materialOptions: " + materialOption.name);
                var materialOptionsArr = [];
                for (var j =0; j< materialOption.materials.length; j++) {
                    console.log("  material: " + materialOption.materials[j].material);
                    materialOptionsArr.push(materialOption.materials[j].material);
                }
                materialOption.materialOptionsArr = materialOptionsArr;
                API[materialOption.name] = materialOption.materials[0].material;
                gui.add( API, materialOption.name, materialOptionsArr ).onChange( updateMaterial);
            }
        }
        //gui.add(API, 'price').name( 'Precio:' );
        gui.add(API, 'renders').name( 'Renders:' );

        const textureFolder = gui.addFolder( 'texture properties' );
        textureFolder.close();
        textureFolder.add( API, 'offsetX', 0.0, 1.0 ).name( 'offset.x' ).onChange( updateUvTransform );
        textureFolder.add( API, 'offsetY', 0.0, 1.0 ).name( 'offset.y' ).onChange( updateUvTransform );
        textureFolder.add( API, 'repeatX', 0.25, 2.0 ).name( 'repeat.x' ).onChange( updateUvTransform );
        textureFolder.add( API, 'repeatY', 0.25, 2.0 ).name( 'repeat.y' ).onChange( updateUvTransform );
        textureFolder.add( API, 'rotation', - 2.0, 2.0 ).name( 'rotation' ).onChange( updateUvTransform );
        textureFolder.add( API, 'centerX', 0.0, 1.0 ).name( 'center.x' ).onChange( updateUvTransform );
        textureFolder.add( API, 'centerY', 0.0, 1.0 ).name( 'center.y' ).onChange( updateUvTransform );
        
        const settingsFolder = gui.addFolder( 'settings' );
        settingsFolder.open();
        settingsFolder.add( settings, 'debug' ).onChange( debug );
        settingsFolder.add( settings, 'axes' ).onChange( axes );
        settingsFolder.add( settings, 'UV' ).onChange( setUV );

        //addGuiPiece(API, designObj, piecesFolder,"");  only when "reload GUI" pressed
            
        API["Render"] = updateMeasures;
        gui.add( API, "Render").name( 'Render' )
        API["reload GUI"] = reloadGuiPieces;
        gui.add( API, "reload GUI").name( 'Load pieces GUI' )


    }
    
    function reloadGuiPieces() {
        if (guiPieces != null) guiPieces.destroy();
        var piecesFolder = gui.addFolder( 'Pieces' );
        piecesFolder.open();
        addGuiPiece(API, designObj, piecesFolder,"");
        guiPieces = piecesFolder;
    }
    
    function addGuiPiece(API, guiPiece, folder, level) {
        for (var i =0; i< guiPiece.pieces.length; i++) {
            //console.log("Piece: " + guiPiece.pieces[i].name + " lx:" + eval(guiPiece.pieces[i].lx).toFixed(2) + " ly:" + eval(guiPiece.pieces[i].ly).toFixed(2) + " lx:" + eval(guiPiece.pieces[i].lz).toFixed(2));
            //gui
            for (var array_j = 0; array_j < guiPiece.pieces[i].array.length ; array_j++) {
                var array_level = level + "_" + array_j; 
                var name = guiPiece.pieces[i].name + array_level;
                API[name] = true;
                API[name + "array_index"] = guiPiece.pieces[i].array[array_j];
                folder.add( API, name).onChange( visibility);
                if ('subsystem' in guiPiece.pieces[i]) {
                    var subFolder = folder.addFolder( name );
                    subFolder.close();
                    addGuiPiece(API, guiPiece.pieces[i].array[array_j].subsystemDesign, subFolder, array_level)
                }
            }
        }

    }
    
  //]]></script>

<script>

    var parameterProperties = ["name", "type", "min","max", "step", "default"];
    var pieceProperties1 = ["name", "type"];
    var pieceProperties3 = ["material", "array_size", "sx", "sy", "sz", "rx", "ry", "rz", "x", "y", "z"];
    var typeProperties = {};
    typeProperties["Box"] = ["lx","ly", "lz"];
    typeProperties["Cylinder"] = ["rt","rb", "lz"];
    typeProperties["Triangle"] = ["b","h", "d", "lz"];
    typeProperties["Extrude"] = ["shape_array", "lz"];
    /*
    <-->d
       /\      |h
      /  \     |
     /    \    |
    /______\   |
    <------>b

    */
    typeProperties["Gltf"] = ["url"];
    typeProperties["Module"] = ["subsystem", "parameters"];
    var pieceProperties = {};
    piecePropertiesTable        = pieceProperties1.concat(["parameters"], pieceProperties3);
    pieceProperties["Box"]      = pieceProperties1.concat(typeProperties["Box"],      pieceProperties3);
    pieceProperties["Cylinder"] = pieceProperties1.concat(typeProperties["Cylinder"], pieceProperties3);
    pieceProperties["Triangle"] = pieceProperties1.concat(typeProperties["Triangle"], pieceProperties3);
    pieceProperties["Extrude"]  = pieceProperties1.concat(typeProperties["Extrude"], pieceProperties3);
    pieceProperties["Gltf"]     = pieceProperties1.concat(typeProperties["Gltf"],     pieceProperties3);
    pieceProperties["Module"]   = pieceProperties1.concat(typeProperties["Module"],   pieceProperties3);

    var subsystemParameterProperties = ["name", "default"];


    function exportCollection() {
        collectionExport = {};
        //collectionExport.materials = materialsObj;
        //collectionExport.materialOptions = materialOptionsObj;
        collectionExport.materialsArr = {};
        collectionExport.designArr = {};
        for (var prop in designArr) {
            if (Object.prototype.hasOwnProperty.call(designArr, prop)) {
                collectionExport.designArr[prop] = {};
                collectionExport.designArr[prop].name = designArr[prop].name;
                // Parameters
                collectionExport.designArr[prop].parameters = [];
                for (var i =0; i< designArr[prop]['parameters'].length; i++) {
                    collectionExport.designArr[prop].parameters[i] = {};
                    for (var j =0; j< parameterProperties.length; j++) {
                        collectionExport.designArr[prop].parameters[i][parameterProperties[j]] = designArr[prop]['parameters'][i][parameterProperties[j]];
                        
                    }
                }
                // Pieces
                collectionExport.designArr[prop].pieces = [];
                for (var i =0; i< designArr[prop]['pieces'].length; i++) {
                    collectionExport.designArr[prop].pieces[i] = {};
                    type = designArr[prop]['pieces'][i].type;
                    if (type == null || type == "") type = "Box";
                    for (var j =0; j< pieceProperties[type].length; j++) {
                        collectionExport.designArr[prop].pieces[i][pieceProperties[type][j]] = designArr[prop]['pieces'][i][pieceProperties[type][j]];
                        
                    }
                }

            }
        }
        document.getElementById('jsonObj').value = JSON.stringify(collectionExport)
    }

    
    function printModelTable(modelName, obj) {
        var modelDiv = document.getElementById('modelDiv')

        var divEl = document.getElementById(modelName);
        if (divEl == null) {  // create node or delete content node
            divEl = document.createElement("DIV");
            divEl.setAttribute("id", modelName);
            modelDiv.appendChild( divEl);
        } else {
            divEl.textContent = ''
        }
        var H1El = document.createElement("H1");
                //H1El.setAttribute("onClick", "editObjectName('" + modelName + "'))");
                H1El.setAttribute("onClick", "editObjectName('" + modelName + "')");
        H1El.innerHTML  = modelName;
        divEl.appendChild( H1El);
        
        // Load object
        var aEl = document.createElement("A");
        aEl.setAttribute("onClick", "loadObject('" + modelName + "')");
        aEl.setAttribute("class", "objectLink loadLink");
        var linkText = document.createTextNode("Load object");
        aEl.appendChild(linkText);
        aEl.href = "javascript:void(0);";
        divEl.appendChild(aEl);        

        // Duplicate object
        var dEl = document.createElement("A");
        dEl.setAttribute("onClick", "duplicateObject('" + modelName + "')");
        dEl.setAttribute("class", "objectLink duplicateLink");
        var linkText = document.createTextNode("Duplicate object");
        dEl.appendChild(linkText);
        dEl.href = "javascript:void(0);";
        divEl.appendChild(dEl);        

        // Parameters
        var H2parametersEl = document.createElement("H2");
        H2parametersEl.innerHTML  = "Parameters";
        divEl.appendChild( H2parametersEl);
        var tableEl = createTable(modelName, obj.parameters, "obj_parameter", parameterProperties);
        divEl.appendChild( tableEl);

        // Pieces
        var H2piecesEl = document.createElement("H2");
        H2piecesEl.innerHTML  = "Pieces";
        divEl.appendChild( H2piecesEl);
        type = obj.type;
        if (type == null || type == "") type = "Box";
        var tableEl = createTable(modelName, obj.pieces, "obj_piece", piecePropertiesTable);
        divEl.appendChild( tableEl);
    }

    function editObjectName(modelName) {
        console.log("previous name: " + modelName);
        
        let newName = prompt("Enter the new name for " + modelName, modelName);
        if (newName != null && newName != modelName) {
            console.log("new name: " + newName);
            designArr[modelName].name = newName;
            designArr[newName] = designArr[modelName]; // on object create new key name. Assign old value to this
            delete designArr[modelName]; 
            init();
        }
    }

    function loadObject(modelName) {
        exportCollection();
        designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
        designObj = designArr[modelName];
        init();
    }

    function duplicateObject(modelName) {
        exportCollection();
        designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
        designObj2 = JSON.parse(JSON.stringify(designArr[modelName]));
        newName = modelName + "_2";
        designObj2.name = newName;
        designArr[newName] = designObj2;
        designObj = designArr[newName];
        init();
    }

    function createTable(modelName, objArray, form_entity, properties, i_element) {
        // i_element only used in obj_subsystem_parameter
        var tableEl = document.createElement("TABLE");
        tableEl.setAttribute("border", "1");
        var trEl = document.createElement("TR");
        //first row (header)
        addNew(trEl, modelName, form_entity, i_element);
        for (var j =0; j< properties.length; j++) {
            addHeader(trEl, properties[j]);
        }
        tableEl.appendChild(trEl);

        for (var i =0; i< objArray.length; i++) {
            //setDefaultValues(objArray[i]);
            //console.log("Piece: " + obj.pieces[i].name + " lx:" + eval(obj.pieces[i].lx).toFixed(2));
            var trEl = document.createElement("TR");

            addEdit(trEl, i, modelName, form_entity, i_element);
            for (var j =0; j< properties.length; j++) {
                addCell(trEl, objArray[i], properties[j], i, modelName, form_entity);
            }
            tableEl.appendChild(trEl);
        }
        return tableEl;
    }

    function addHeader(trEl, property) {
        var tdEl = document.createElement("TH");
        var textNode = document.createTextNode(property);
        tdEl.appendChild(textNode);
        trEl.appendChild(tdEl);
    }
    function addCell(trEl, obj, property, i_piece, modelName, form_entity) {  // obj is piece or a parameter
        var tdEl = document.createElement("TD");
        var textContent = "";
        if (form_entity == "obj_piece" && property == "type") {   // this if can be deleted when the data are right
            if (obj[property] == null || obj[property] == "") {
                obj[property] = "Box";
            }
        }
        if (form_entity == "obj_piece" && property == "parameters") {
            val = "";
            for (var k =0; k< typeProperties[obj.type].length; k++) {
                if (k > 0) val += " - ";
                typeProperty = typeProperties[obj.type][k];
                if (typeProperty == "parameters") {
                    tdEl.innerHTML = linkTableSusbsystemParameter(i_piece, modelName, "obj_subsystem_parameter");
                } else {
                    val += obj[typeProperty];
                }
            }
            textContent = val;
            textNode = document.createTextNode(textContent);
            tdEl.appendChild(textNode);
        } else if (obj[property] != null && obj[property] != "") {
            textContent = obj[property];
            textNode = document.createTextNode(textContent);
            tdEl.appendChild(textNode);
        }

        
        /*
        if (obj[property] != null && obj[property] != "") {
            if (property == "parameters") {
                tdEl.innerHTML = linkTableSusbsystemParameter(i_piece, modelName, "obj_subsystem_parameter");
            } else {
                textContent = obj[property];
                textNode = document.createTextNode(textContent);
                tdEl.appendChild(textNode);
            }
        }
        */
        trEl.appendChild(tdEl);
    }

    function createTableSusbsystemParameter(i_element, modelName, form_entity) {
        var divEl = addDivForEdit(modelName);
        var H3El = document.createElement("H3");
        H3El.innerHTML  = "Parameters of " + modelName 
          + " piece " + i_element + ": " + designArr[modelName].pieces[i_element]["name"]
          + " (" + designArr[modelName].pieces[i_element]["subsystem"] + ")";
        divEl.appendChild( H3El);

        var objArray = designArr[modelName].pieces[i_element]["parameters"];
        var tableEl = createTable(modelName, objArray, form_entity, subsystemParameterProperties, i_element);
        divEl.appendChild( tableEl);
    }
// link al form que editará los parametros desde createTableSusbsystemParameter
    function editParameter(i_piece, modelName, form_entity) {
          return "<a onclick='createForm(" + i_piece + ", \"" + modelName + "\",\"E\", \"" + form_entity + "\")' href='javascript:void(0);'>Edit</a>";
    }


    function linkTableSusbsystemParameter(i_piece, modelName, form_entity) {
          return "<a onclick='createTableSusbsystemParameter(" + i_piece + ", \"" + modelName + "\", \"" + form_entity + "\")' href='javascript:void(0);'>Edit</a>";
    }


    function addNew(trEl, modelName, form_entity, i_piece) {
        var tdEl = document.createElement("TD");
        tdEl.setAttribute("class", "new");
        tdEl.innerHTML = 
          "<a onclick='createForm(" + -1 + ", \"" + modelName + "\",\"N\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'>New</a>";
        trEl.appendChild(tdEl);
    }

    function addEdit(trEl, i_row, modelName, form_entity, i_piece) {
        var tdEl = document.createElement("TD");
        tdEl.setAttribute("class", "edit");
        tdEl.innerHTML = 
          "<a onclick='createForm(" + i_row + ", \"" + modelName + "\",\"E\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'>Edit</a>" + "&nbsp;&nbsp;" + 
          "<a onclick='createForm(" + i_row + ", \"" + modelName + "\",\"D\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'>Duplicate</a>";
        trEl.appendChild(tdEl);
    }


    function addDivForEdit(modelName) {
        var formEl = document.getElementById("editObject");
        if (formEl != null) {
            formEl.remove();
        }

        formEl = document.createElement("DIV");  //Changed from FORM to DIV to prevent send
        formEl.setAttribute("id", "editObject");
//        formEl.setAttribute("method", "GET");
//        formEl.setAttribute("action", "javascript:void(0);");
        document.getElementById(modelName).appendChild(formEl);
        return formEl;
    }

    function createForm(i_array, modelName, formType, form_entity, i_element) {
        console.log("createForm " + i_element);
        
        var formEl = addDivForEdit(modelName);
        formEl.appendChild(addHiddenField("sys_object", modelName));
        formEl.appendChild(addHiddenField("sys_formType", formType));
        formEl.appendChild(addHiddenField("sys_array", i_array));
        var objectElement;
        if (form_entity == "obj_parameter") {
            formEl.appendChild(addHiddenField("sys_type", "sys_parameter"));
            objectElement = designArr[modelName].parameters[i_array];
            properties = parameterProperties;
        } else if (form_entity == "obj_piece") {
            formEl.appendChild(addHiddenField("sys_type", "sys_piece"));
            objectElement = designArr[modelName].pieces[i_array];
            if (objectElement != null) type = objectElement.type;
            if (type == null || type == "") type = "Box";
            properties = pieceProperties[type];
        } else if (form_entity == "obj_subsystem_parameter") {
            formEl.appendChild(addHiddenField("sys_type", "sys_subsystem_parameter"));
            formEl.appendChild(addHiddenField("sys_element", i_element));
            objectElement = designArr[modelName].pieces[i_element]["parameters"][i_array];
            properties = subsystemParameterProperties;
        } else {
            console.log("form_entity: " + form_entity + " not defined *********");
        }

        for (var j =0; j< properties.length; j++) {
            var propertyName  = properties[j];
            var propertyValue = "";
            if (formType != "N") {
                if (objectElement[properties[j]] != null) {
                    propertyValue = objectElement[properties[j]];
                }
            }
            if (form_entity == "obj_piece" && propertyName == "shape_array") {
                console.log("shape_array");
                createShapeForm(propertyValue, formEl);
            } else {
                var divEl = document.createElement("DIV");
                var span1El = document.createElement("SPAN");
                var text1Node = document.createTextNode(propertyName);
                divEl.appendChild(span1El);
                span1El.appendChild(text1Node);
                var span2El = document.createElement("INPUT");
                span2El.setAttribute("id", propertyName);
                span2El.value = propertyValue;
                divEl.appendChild(span2El);
                formEl.appendChild(divEl);
            }
        }
        var buttonEl = document.createElement("BUTTON");
        buttonEl.setAttribute("onClick", "updateObject()");
        var t = document.createTextNode("Save");
        buttonEl.appendChild(t);
        formEl.appendChild(buttonEl);
        var buttonCancelEl = document.createElement("BUTTON");
        buttonCancelEl.setAttribute("onClick", "cancelEdit()");
        var t = document.createTextNode("Cancel");
        buttonCancelEl.appendChild(t);
        formEl.appendChild(buttonCancelEl);
    }
    
    var shapePoints;
    function createShapeForm(propertyValue, parentDiv) {
        shapePoints = 0;
        var divEl = document.createElement("DIV");
        divEl.setAttribute("id", "shapeForm");
        parentDiv.appendChild(divEl);
        divEl.appendChild(createPointOfShapeHeader());
        if (propertyValue == null || propertyValue == "") {
            createPointOfShapeForm(['','']);
            createPointOfShapeForm(['','']);
            createPointOfShapeForm(['','']);
        } else {
            for (var k =0; k< propertyValue.length; k++) {
                createPointOfShapeForm(propertyValue[k]);
            }
        }
        var buttonLineEl = document.createElement("BUTTON");
        buttonLineEl.setAttribute("id", "addShapeLine");
        buttonLineEl.setAttribute("onClick", "createPointOfShapeForm(['',''])");
        var t = document.createTextNode("Add Line");
        buttonLineEl.appendChild(t);
        divEl.appendChild(buttonLineEl);
        var buttonCurveEl = document.createElement("BUTTON");
        buttonCurveEl.setAttribute("id", "addShapeCurve");
        buttonCurveEl.setAttribute("onClick", "createPointOfShapeForm(['','','','','',''])");
        var t = document.createTextNode("Add Curve");
        buttonCurveEl.appendChild(t);
        divEl.appendChild(buttonCurveEl);
        
        return divEl
    }
    function createPointOfShapeHeader() {
        var divEl = document.createElement("DIV");
        var span1El = document.createElement("SPAN");
        var text1Node = document.createTextNode("Shape points");
        span1El.appendChild(text1Node);
        divEl.appendChild(span1El);
        var span1El = document.createElement("SPAN");
        var text1Node = document.createTextNode("X");
        span1El.setAttribute("class", "pointHeader");
        span1El.appendChild(text1Node);
        divEl.appendChild(span1El);
        var span2El = document.createElement("SPAN");
        var text2Node = document.createTextNode("Y");
        span2El.setAttribute("class", "pointHeader");
        span2El.appendChild(text2Node);
        divEl.appendChild(span2El);
        return divEl
    }
    inputNames = ["x", "y", "c1x", "c1y","c2x","c2y"];
    function createPointOfShapeForm(pointValue) {
        shapePoints++;
        var divEl = document.createElement("DIV");
        var span1El = document.createElement("SPAN");
        var text1Node = document.createTextNode("Point " + shapePoints);
        span1El.appendChild(text1Node);
        divEl.appendChild(span1El);
        
        for (i_point = 0; i_point < pointValue.length; i_point++) {
            var spanXEl = document.createElement("INPUT");
            point_id = inputNames[i_point] + "_" + shapePoints;
            spanXEl.setAttribute("id", point_id);
            spanXEl.setAttribute("class", "point");
            spanXEl.value = pointValue[i_point];
            divEl.appendChild(spanXEl);
        }
        
/*
        var spanXEl = document.createElement("INPUT");
        point_id = "x_" + shapePoints;
        spanXEl.setAttribute("id", point_id);
        spanXEl.setAttribute("class", "x_point");
        spanXEl.value = pointValue[0];
        divEl.appendChild(spanXEl);
        
        var spanYEl = document.createElement("INPUT");
        point_id = "y_" + shapePoints;
        spanYEl.setAttribute("id", point_id);
        spanYEl.setAttribute("class", "y_point");
        spanYEl.value = pointValue[1];
        divEl.appendChild(spanYEl);
*/        
        document.getElementById("shapeForm").appendChild(divEl);
        buttonAdd = document.getElementById("addShapeLine");
        if (buttonAdd != null) {
            document.getElementById("shapeForm").appendChild(buttonAdd); // move to the end of the points
        }
        buttonAdd = document.getElementById("addShapeCurve");
        if (buttonAdd != null) {
            document.getElementById("shapeForm").appendChild(buttonAdd); // move to the end of the points
        }
        return divEl
    }
    function addHiddenField(name, value) {
        var hiddenEl = document.createElement("INPUT");
        hiddenEl.setAttribute("id", name);
        hiddenEl.setAttribute("type", "text");
        hiddenEl.value = value;
        return hiddenEl;
    }
    function updateObject() {
        console.log("editObject");
        var formEl = document.getElementById("editObject");
        
        var sys_type = document.getElementById("sys_type").value;
        var sys_object = document.getElementById("sys_object").value;
        var objectArray;
        if (sys_type == "sys_parameter") {
            objectArray = designArr[sys_object].parameters;
            properties = parameterProperties;
        } else if (sys_type == "sys_piece") {
            objectArray = designArr[sys_object].pieces;
            type = document.querySelector("div#editObject #type").value;
            if (type == null || type == "") type = "Box";
            properties = pieceProperties[type];
        } else if (sys_type == "sys_subsystem_parameter") {
            var sys_element = document.getElementById("sys_element").value;
            if (!Array.isArray(designArr[sys_object].pieces[sys_element]["parameters"])) {  // create the array for the parameters
                designArr[sys_object].pieces[sys_element]["parameters"] = [];
            }
            objectArray = designArr[sys_object].pieces[sys_element]["parameters"];
            properties = subsystemParameterProperties;
        } else {
            console.log("sys_type: " + sys_type + " not defined *********");
        }

        pieceObj = {}
        var sys_formType = document.getElementById("sys_formType").value;
        var sys_array = document.getElementById("sys_array").value;

        for (var j =0; j< properties.length; j++) {
            var propertyName  = properties[j];
            if (sys_type == "sys_piece" && propertyName == "shape_array") {
                console.log("updateObject shape_array");
                shapeArray = readShapeArray();
                pieceObj[propertyName] = shapeArray;
            } else {
                field = document.querySelector("div#editObject #" + propertyName);
                var propertyValue = null;
                if (field != null) {
                    propertyValue  = 
                    field.value;
                }
                if (propertyValue != "") {  // not set void properties
                    if (propertyName == "parameters") {  // not update parameters 
                        if (sys_formType != "N") {
                            pieceObj[propertyName] = objectArray[sys_array]["parameters"];  // get the parameters from the original
                        }
                    } else {
                        pieceObj[propertyName] = propertyValue;
                    }
                }
            }
        }
        console.log("object created");
        if (sys_formType == "E") {
            objectArray[sys_array] = pieceObj;
        } else if (sys_formType == "D" || sys_formType == "N"){
            objectArray.push(pieceObj);
        } else {
            console.log("sys_formType: " + sys_formType + " not defined *********");
        }
        if (sys_type == "sys_subsystem_parameter") {
            createTableSusbsystemParameter(document.getElementById("sys_element").value, sys_object, "obj_subsystem_parameter");
        } else {
            printModelTable(sys_object, designArr[sys_object]);
        }
    }
    function readShapeArray() {
        shapeArray = [];
        for (var k =1; k<= shapePoints; k++) {
            point = [];
            xValue = document.getElementById("x_" + k);
            yValue = document.getElementById("y_" + k);
            if (xValue != null && yValue != null && xValue.value != "" && yValue.value != "") {
                point[0] = xValue.value;
                point[1] = yValue.value;
                // "c1x", "c1y","c2x","c2y"
                c1xValue = document.getElementById("c1x_" + k);
                if (c1xValue != null && c1xValue.value != "") point[2] = c1xValue.value;
                c1yValue = document.getElementById("c1y_" + k);
                if (c1yValue != null && c1yValue.value != "") point[3] = c1yValue.value;
                c2xValue = document.getElementById("c2x_" + k);
                if (c2xValue != null && c2xValue.value != "") point[4] = c2xValue.value;
                c2yValue = document.getElementById("c2y_" + k);
                if (c2yValue != null && c2yValue.value != "") point[5] = c2yValue.value;

                shapeArray.push(point);
            }
        }
        return shapeArray;
    }
    function cancelEdit() {
        var formEl = document.getElementById("editObject");
        if (formEl != null) {
            formEl.remove();
        }
    }
</script>
<script>
            function getMaterial(name) {
                for (var i =0; i< materialsObj.materials.length; i++) {
                    if (name == materialsObj.materials[i].name) {
                        return materialsObj.materials[i];
                    }
                }
                return null;  // name not found 
            }
            function getPiece(name) {
                for (var i =0; i< designObj.pieces.length; i++) {
                    if (name == designObj.pieces[i].name) {
                        return designObj.pieces[i];
                    }
                }
                return null;  // name not found 
            }
            
            function isObject(obj) {
                return obj != null && obj.constructor.name === "Object"
            }
            function isMesh(obj) {
                return obj != null && obj.constructor.name === "Mesh"
            }
            function isGroup(obj) {
                return obj != null && obj.constructor.name === "Group"
            }
            function updateMeasuresAPI(node, THREE, API, updateDesign){
//                updateDesign.eval = makeEvalContext ();
//                updateDesign.eval(evalText);
                eval(updateDesign.evalText);    // initial evalText
                console.log("eval " + updateDesign.name + " " + updateDesign.evalText);
                for (var i =0; i< updateDesign.pieces.length; i++) {

                    // we define the parameters of the subsystem with the values of the updateDesign, but will apply them to the subsystem (before the call to updateMeasuresAPI.
                    var subsetEvalText = "";
                    if ('subsystem' in updateDesign.pieces[i]) {
                        for (var j =0; j< updateDesign.pieces[i].parameters.length; j++) {
                                subsetEvalText = subsetEvalText + updateDesign.pieces[i].parameters[j].name + "=" + Number(eval(updateDesign.pieces[i].parameters[j].default)) + ";";
                        }
                    }

                    var array_length;
                    if ('array_size' in updateDesign.pieces[i]) {
                        array_length = Math.round(eval(updateDesign.pieces[i].array_size));
                    } else {
                        array_length = 1;
                    }
                    if (updateDesign.pieces[i].array == null) {
                        console.log("Create array for piece " + i + " array_length: " + array_length + " " + updateDesign.name);
                        updateDesign.pieces[i].array = [];
                    }
                  //for (var array_i = 0; array_i < updateDesign.pieces[i].array.length ; array_i++) {
                    for (var array_j = array_length; array_j < updateDesign.pieces[i].array.length ; array_j++) {
                        console.log("Change visibilit of " + i + " array: " + array_j);
                        updateDesign.pieces[i].array[array_j].mesh.visible = false;
                    }
                    for (var array_i = 0; array_i < array_length ; array_i++) {
                        if (!isObject(updateDesign.pieces[i].array[array_i])) {
                            console.log("Create object " + array_i);
                            updateDesign.pieces[i].array[array_i] = {}
                        }
                        updateDesign.pieces[i].array[array_i].evalText = updateDesign.evalText + "array_i = " + array_i + ";" + "array_n = " + array_length + ";";
                        console.log("eval piece " + i + " "  + updateDesign.name + " evalText: " + updateDesign.pieces[i].array[array_i].evalText);
                        eval(updateDesign.pieces[i].array[array_i].evalText);
                        if ('subsystem' in updateDesign.pieces[i]) {
                            var dot;
                            if (!isGroup(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Create mesh dot");
                                dot = createGroup(THREE);
                                updateDesign.pieces[i].array[array_i].mesh=dot;
                                if (node == null) debugger;
                                node.add( dot );
                                var clonedDesign = JSON.parse(JSON.stringify(designArr[updateDesign.pieces[i].subsystem]));
                                updateDesign.pieces[i].array[array_i].subsystemDesign = clonedDesign;
                            } else {
                                dot = updateDesign.pieces[i].array[array_i].mesh;
                            }
                          //addDesign(dot, updateDesign.pieces[i].array[array_i].subsystemDesign);
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));

                            updateDesign.pieces[i].array[array_i].subsystemDesign.evalText = "context='" +  
                              updateDesign.pieces[i].name +"';" + subsetEvalText;  // only their parameters, not array_i
                            console.log("eval piece " + i + " array_i: " + array_i 
                              + " subsystem: " + updateDesign.pieces[i].subsystem
                              + " evalText: " + updateDesign.pieces[i].array[array_i].subsystemDesign.evalText);
                            updateMeasuresAPI(dot, THREE, API, updateDesign.pieces[i].array[array_i].subsystemDesign);
                            eval(updateDesign.evalText);    // restore evalText
                        //} else if ('gltf' in updateDesign.pieces[i]) {
                        } else if (updateDesign.pieces[i].type == 'Gltf') {
                            if (!isGroup(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Objecto GLTF");
                                const loader = new loaders.GLTFLoader();
                                dot = createGroup(THREE);
                                dot.name = "gltf object"
                                updateDesign.pieces[i].array[array_i].mesh=dot;
                                if (node == null) debugger;
                                node.add( dot );
                                dot.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                    
                                const addSceneCallback = prepareACallbackFunctionForLoader(dot);
                                loader.load(updateDesign.pieces[i].url,   addSceneCallback, undefined, function ( error ) {
                                    console.error( error );

                                } )
                            }
/*                            loader.load( 'models/legoCube/scene.gltf', function ( gltf) {
                                //updateDesign.pieces[i].array[array_i].mesh=gltf;
                                dot.add( gltf.scene );
                                dot.name = "gltf object load"
                                //search por gltf.parser.options.path = 'models/legoCube/'
//                                updateDesign.pieces[i].scene = gltf;
                                gltf.scene.scale.set(0.1, 0.3, 0.1); 
                            }, undefined, function ( error ) {
                                console.error( error );

                            } );
                            */
                            // Position
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));

// Cylinder 
                        } else if (updateDesign.pieces[i].type == 'Cylinder') {
                            if (!isMesh(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Create mesh geometry");
                                geometry = new THREE.CylinderGeometry( 1., 1., 1., 32 );

                                //geometry.translate( 0.5, 0.5, 0.5 ) ;
                                mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_i].mesh=mesh;
                                updateDesign.pieces[i].array[array_i].mesh.rt = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.rb = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.lz = 1.;
                                node.add( mesh );
                            }
                            // Position
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));
// Triangle 
                        } else if (updateDesign.pieces[i].type == 'Triangle') {
                            if (!isMesh(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Create Triangle geometry");
                                
                                const shape = new THREE.Shape();
                                shape.moveTo( 0,0 );
                                shape.lineTo( 0, 1 );
                                shape.lineTo( 1, 0.5 );
                                shape.lineTo( 0, 0 );

                                const extrudeSettings = {
                                    bevelEnabled: false
                                };

                                const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

                                mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_i].mesh=mesh;
                                updateDesign.pieces[i].array[array_i].mesh.b = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.h = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.d = 0.5;
                                updateDesign.pieces[i].array[array_i].mesh.lz = 1.;
                                node.add( mesh );
                            }
                            // Position
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));

// Extrude 
                        } else if (updateDesign.pieces[i].type == 'Extrude') {
                            if (!isMesh(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Create Extrude geometry");
                                
                                const shape = new THREE.Shape();
                                shape.moveTo( 0,0 );
                                shape.lineTo( 0, 1 );
                                shape.lineTo( 1, 0.5 );
                                shape.lineTo( 0, 0 );

                                const extrudeSettings = {
                                    bevelEnabled: false
                                };

                                const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

                                mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_i].mesh=mesh;
                                //updateDesign.pieces[i].array[array_i].mesh.b = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.shape_array = [];
                                shape_array = updateDesign.pieces[i].shape_array;
                                for (var k =0; k< shape_array.length; k++) {
                                    updateDesign.pieces[i].array[array_i].mesh.shape_array[k] = [];
                                    updateDesign.pieces[i].array[array_i].mesh.shape_array[k][0] = 0;
                                    updateDesign.pieces[i].array[array_i].mesh.shape_array[k][1] = 0;
                                }

                                updateDesign.pieces[i].array[array_i].mesh.lz = 0.076;  // random number
                                node.add( mesh );
                            }
                            // Position
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));

// Box
                        } else {
                            if (updateDesign.pieces[i].type != 'Box') {
                                console.warn("type not defined for piece :" + i + " type: " + updateDesign.pieces[i].type);
                                updateDesign.pieces[i].type = "Box";
                            }
                            if (!isMesh(updateDesign.pieces[i].array[array_i].mesh)) {
                                console.log("Create mesh geometry");
                                geometry = new THREE.BoxGeometry( 1., 1., 1. );

                                geometry.translate( 0.5, 0.5, 0.5 ) ;
                                mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_i].mesh=mesh;
                                updateDesign.pieces[i].array[array_i].mesh.lx = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.ly = 1.;
                                updateDesign.pieces[i].array[array_i].mesh.lz = 1.;
                                node.add( mesh );
                            }
// Position
                            updateDesign.pieces[i].array[array_i].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));

                        }
                        // Set default values if non exist
                        setDefaultValues(updateDesign.pieces[i]);
                        if (updateDesign.pieces[i].array[array_i].mesh != undefined) {
                            updateDesign.pieces[i].array[array_i].mesh.visible = true;


                            // Box
                            if (updateDesign.pieces[i].array[array_i].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Box") {  // geometry.type == "BoxGeometry" We compare with pieces.type because different types can share same geometry.type

                                    lx = eval(updateDesign.pieces[i].lx);
                                    ly = eval(updateDesign.pieces[i].ly);
                                    lz = eval(updateDesign.pieces[i].lz);

                                    if (updateDesign.pieces[i].array[array_i].mesh.lx != lx ||
                                        updateDesign.pieces[i].array[array_i].mesh.ly != ly ||
                                        updateDesign.pieces[i].array[array_i].mesh.lz != lz) {  // only create if theres is a change

                                        updateDesign.pieces[i].array[array_i].mesh.lx = lx;
                                        updateDesign.pieces[i].array[array_i].mesh.ly = ly;
                                        updateDesign.pieces[i].array[array_i].mesh.lz = lz;

                                        updateDesign.pieces[i].array[array_i].mesh.geometry.dispose();
                                        updateDesign.pieces[i].array[array_i].mesh.geometry =  new THREE.BoxGeometry(lx, ly, lz); 
                                        updateDesign.pieces[i].array[array_i].mesh.geometry.translate(lx/2, ly/2, lz/2);
                                    }
                                    
                                //scale texture
                                //we change the uv coordinates of the geometry, so the same texture can be applied to different faces and different pieces
                                //Float32Array(48) [0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,
                                //                 000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647
                                uva= updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").array;
                                // face 1 (X=1) (1,1,1) 0, 1, 1, 1, 0, 0, 1, 0,
                                //Face 1
                                var ini = 0;
                                uva[ini + 1] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 3] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lz);
                                //Face 2
                                var ini = ini + 8;
                                uva[ini + 1] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 3] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lz);
                                //Face 3
                                var ini = ini + 8;
                                uva[ini + 1] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lx);
                                uva[ini + 3] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lx);
                                //Face 4
                                var ini = ini + 8;
                                uva[ini + 1] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lx);
                                uva[ini + 3] = eval(updateDesign.pieces[i].lz);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lx);
                                //Face 5
                                var ini = ini + 8;
                                uva[ini + 1] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lx);
                                uva[ini + 3] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lx);
                                //Face 6
                                var ini = ini + 8;
                                uva[ini + 1] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 2] = eval(updateDesign.pieces[i].lx);
                                uva[ini + 3] = eval(updateDesign.pieces[i].ly);
                                uva[ini + 6] = eval(updateDesign.pieces[i].lx);
                                updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                    
                            }
                                   
                            // Cylinder
                            if (updateDesign.pieces[i].array[array_i].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Cylinder") {  // geometry.type == "CylinderGeometry"
                                    rt = eval(updateDesign.pieces[i].rt);
                                    rb = eval(updateDesign.pieces[i].rb);
                                    lz = eval(updateDesign.pieces[i].lz);

                                    if (updateDesign.pieces[i].array[array_i].mesh.rt != rt ||
                                        updateDesign.pieces[i].array[array_i].mesh.rb != rb ||
                                        updateDesign.pieces[i].array[array_i].mesh.lz != lz) {  // only create if theres is a change

                                        updateDesign.pieces[i].array[array_i].mesh.rt = rt;
                                        updateDesign.pieces[i].array[array_i].mesh.rb = rb;
                                        updateDesign.pieces[i].array[array_i].mesh.lz = lz;

                                        updateDesign.pieces[i].array[array_i].mesh.geometry.dispose();
                                        updateDesign.pieces[i].array[array_i].mesh.geometry =  new THREE.CylinderGeometry(rt, rb, lz, 32); 
                                        //updateDesign.pieces[i].array[array_i].mesh.geometry.translate(rt/2, rb/2, lz/2);

                                        //scale texture
                                        //we change the uv coordinates of the geometry, so the same texture can be applied to different faces and different pieces
                                        //Float32Array(392) [0, 1, 0.03125, 1, ... 
                                        uva= updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").array;
                                        
                                        /*
                                        33     lateral v = 1
                                        33  66 lateral v = 0
                                        32 132 centro top
                                        33 196 circulo
                                        32 262 centro botttom
                                        33 326 circulo
                                           392
                                        */
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[iuv]     *= rt * 2 * Math.PI;
                                            uva[iuv + 1] *= lz;
                                        }
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[66 + iuv]     *= rb * 2 * Math.PI;
                                            //uva[66 + iuv + 1] *= lz;  // os 0
                                        }
                                        // circle top
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[196 + iuv]     = (uva[196 + iuv]-0.5)*rt*2+0.5;
                                            uva[196 + iuv + 1] = (uva[196 + iuv + 1]-0.5)*rt*2+0.5;  // os 0
                                        }
                                        // circle bottom
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[326 + iuv]     = (uva[326 + iuv]-0.5)*rb*2+0.5;
                                            uva[326 + iuv + 1] = (uva[326 + iuv + 1]-0.5)*rb*2+0.5;  // os 0
                                        }

                                        updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                    }
                            }
                            // Triangle
                            if (updateDesign.pieces[i].array[array_i].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Triangle") {  // geometry.type == "ExtrudeGeometry"
                                    b = eval(updateDesign.pieces[i].b);
                                    h = eval(updateDesign.pieces[i].h);
                                    d = eval(updateDesign.pieces[i].d);
                                    lz = eval(updateDesign.pieces[i].lz);

                                    if (updateDesign.pieces[i].array[array_i].mesh.b != b ||
                                        updateDesign.pieces[i].array[array_i].mesh.h != h ||
                                        updateDesign.pieces[i].array[array_i].mesh.d != d ||
                                        updateDesign.pieces[i].array[array_i].mesh.lz != lz) {  // only create if theres is a change

                                        updateDesign.pieces[i].array[array_i].mesh.b = b;
                                        updateDesign.pieces[i].array[array_i].mesh.h = h;
                                        updateDesign.pieces[i].array[array_i].mesh.d = d;
                                        updateDesign.pieces[i].array[array_i].mesh.lz = lz;

                                        updateDesign.pieces[i].array[array_i].mesh.geometry.dispose();
                                        const shape = new THREE.Shape();
                                        shape.moveTo( 0,0 );
                                        shape.lineTo( b, 0);   
                                        shape.lineTo( d, h );
                                        shape.lineTo( 0, 0 );

                                        const extrudeSettings = {
                                            steps: 1,
                                            depth: lz,
                                            bevelEnabled: false
                                        };

                                        updateDesign.pieces[i].array[array_i].mesh.geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

                                        mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                        mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                        
                                        updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                    }
                            }
                            // Extrude
                            if (updateDesign.pieces[i].array[array_i].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Extrude") {  // geometry.type == "ExtrudeGeometry"
                                    //b = eval(updateDesign.pieces[i].b);
                                    shape_array = updateDesign.pieces[i].shape_array;
                                    lz = eval(updateDesign.pieces[i].lz);

                                    var changeArray = false;
                                    for (var k =0; k< shape_array.length; k++) {
                                        if (updateDesign.pieces[i].array[array_i].mesh.shape_array[k][0] != 
                                           eval(shape_array[k][0])) changeArray = true;
                                        if (updateDesign.pieces[i].array[array_i].mesh.shape_array[k][1] != 
                                           eval(shape_array[k][1])) changeArray = true;
                                    }
                                    if (//updateDesign.pieces[i].array[array_i].mesh.b != b ||
                                        shape_array != null && 
                                        (updateDesign.pieces[i].array[array_i].mesh.lz != lz
                                        || changeArray)) {  // only create if theres is a change

                                        //updateDesign.pieces[i].array[array_i].mesh.b = b;
                                        updateDesign.pieces[i].array[array_i].mesh.lz = lz;
                                        for (var k =0; k< shape_array.length; k++) {
                                            updateDesign.pieces[i].array[array_i].mesh.shape_array[k] = [];
                                            updateDesign.pieces[i].array[array_i].mesh.shape_array[k][0] = 
                                               eval(shape_array[k][0]);
                                            updateDesign.pieces[i].array[array_i].mesh.shape_array[k][1] = 
                                               eval(shape_array[k][1]);
                                        }

                                        updateDesign.pieces[i].array[array_i].mesh.geometry.dispose();
                                        const shape = new THREE.Shape();
                                        shape.moveTo( eval(shape_array[0][0]), eval(shape_array[0][1]));
                                        for (var k =1; k< shape_array.length; k++) {
                                            if (shape_array[k].length == 2) {
                                                shape.lineTo( eval(shape_array[k][0]), eval(shape_array[k][1]));   
                                            } else {
                                                shape.bezierCurveTo(
                                                    eval(shape_array[k][2]), eval(shape_array[k][3]),
                                                    eval(shape_array[k][4]), eval(shape_array[k][5]),
                                                    eval(shape_array[k][0]), eval(shape_array[k][1])
                                                )
                                            }
                                        }
                                        shape.lineTo( eval(shape_array[0][0]), eval(shape_array[0][1]));

                                        const extrudeSettings = {
                                            steps: 1,
                                            depth: lz,
                                            bevelEnabled: false
                                        };

                                        updateDesign.pieces[i].array[array_i].mesh.geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

                                        mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                        mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                        
                                        updateDesign.pieces[i].array[array_i].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                    }
                            }

                                   
/*
 replace scale by update of BoxGeometry
*/

                            updateDesign.pieces[i].array[array_i].mesh.scale.set(
                                eval(updateDesign.pieces[i].sx), 
                                eval(updateDesign.pieces[i].sy), 
                                eval(updateDesign.pieces[i].sz));

                            updateDesign.pieces[i].array[array_i].mesh.rotation.z = 
                                eval(updateDesign.pieces[i].rz) * Math.PI / 180.;
                            updateDesign.pieces[i].array[array_i].mesh.rotation.y = 
                                eval(updateDesign.pieces[i].ry) * Math.PI / 180.;
                            updateDesign.pieces[i].array[array_i].mesh.rotation.x = 
                                eval(updateDesign.pieces[i].rx) * Math.PI / 180.;

                            
/*
                            updateDesign.pieces[i].array[array_i].mesh.position.x = 
                                   Number(eval(updateDesign.pieces[i].x));
                            updateDesign.pieces[i].array[array_i].mesh.position.y = 
                                   Number(eval(updateDesign.pieces[i].y));
                            updateDesign.pieces[i].array[array_i].mesh.position.z = 
                                   Number(eval(updateDesign.pieces[i].z));                            
*/
                        }
                            
                    }
                }
            }
            function setDefaultValues(pieceObj) {
                if (!('sx' in pieceObj)) pieceObj.sx=1;
                if (!('sy' in pieceObj)) pieceObj.sy=1;
                if (!('sz' in pieceObj)) pieceObj.sz=1;
                if (!('rx' in pieceObj)) pieceObj.rx=0;
                if (!('ry' in pieceObj)) pieceObj.ry=0;
                if (!('rz' in pieceObj)) pieceObj.rz=0;
            }
            function prepareACallbackFunctionForLoader(myScene) {
              return function( {scene} ) {
                const object = scene.children[0]
                //object.scale.set(0.2, 0.2, 0.2); 
                //object.visible = false
                  myScene.add(object);
                  updateMeasures();
              } 
              
            }
            function createGroup(THREE) {
/*
                var geometry = new THREE.BufferGeometry();
                const vertices = [];
                vertices.push(new THREE.Vector3( 0, 0, 0));
                var dot = new THREE.Points(geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );

*/
                var dot = new THREE.Group();
                return dot;
            }

            function updateUvTransform(arg) {
                return;
                //if (!settings.UV) return;
                for (var i =0; i< designObj.pieces.length; i++) {
                    var texture;
                    materialObj = getMaterial(designObj.pieces[i].material);
                    if (materialObj.type == "single") { 
                        texture = designObj.pieces[i].mesh.material.map;
                        texture.matrix.identity().scale( updateDesign.eval(designObj.pieces[i].sx), updateDesign.eval(designObj.pieces[i].sy), updateDesign.eval(designObj.pieces[i].sz) )
                    } else {
//                        for (var j =0; j< 6; j++) {
/*                            texture = designObj.pieces[i].mesh.material[0].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sz), eval(designObj.pieces[i].sy))
                            texture = designObj.pieces[i].mesh.material[1].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sz), eval(designObj.pieces[i].sy))
                            texture = designObj.pieces[i].mesh.material[2].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sz))
                            texture = designObj.pieces[i].mesh.material[3].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sz))
                            texture = designObj.pieces[i].mesh.material[4].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sy))
                            texture = designObj.pieces[i].mesh.material[5].map;
                            texture.matrix.identity().scale( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sy))
*/
//                        }
                    }
                }


/*
                    if (settings.UV) {
                        texture = designObj.pieces[0].mesh.material.map;
                    } else {
                        texture = designObj.pieces[0].mesh.material[4].map;
                    }
*/
/*
                    if ( texture.matrixAutoUpdate === true ) {

                        texture.offset.set( API.offsetX, API.offsetY );
                        texture.repeat.set( API.repeatX, API.repeatY );
                        texture.center.set( API.centerX, API.centerY );
                        texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]

                    } else {

                        // one way...
                        //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );

                        // another way...
                        texture.matrix
                            .identity()
                            //.translate( - API.centerX,- API.centerY, 0 )
                            //.rotate( API.rotation )					// I don't understand how rotation can preceed scale, but it seems to be required...
                            //.scale( API.repeatX, API.repeatY, API.repeatZ )
    //                   designObj.pieces[i].mesh.scale.set( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sy), eval(designObj.pieces[i].sz));

                            .scale( eval(designObj.pieces[i].sx), eval(designObj.pieces[i].sy), eval(designObj.pieces[i].sz) )
                        //    .translate( API.centerX, API.centerY )
                            //.translate( API.offsetX, 0, 0 )
                            ;

                    }
                }
*/


            }

</script>

  <script>
    // tell the embed parent frame the height of the content
    if (window.parent && window.parent.parent){
      window.parent.parent.postMessage(["resultsFrame", {
        height: document.body.getBoundingClientRect().height,
        slug: "7u84j6kp"
      }], "*")
    }

    // always overwrite window.name, in case users try to set it manually
    window.name = "result"
  </script>



<style>
#modelDiv {
  margin-left: 2em;
}

#modelDiv h1 a {
    font-size: large;
    margin-left: 1em;
}

#modelDiv .objectLink {
  margin-right: 1em;
}

#modelDiv div#editObject span {
    display: inline-block;
    width: 7em;
    background-color: #bfdfe9;
    margin-right: 1em;
}
#modelDiv div#editObject span.pointHeader {
    width: 4.6em;
    margin-right: 1em;
}
#modelDiv .point {
    width: 5em;
    margin-right: 1em;
}
button#addShapeLine {
    margin-left: 9.6em;
}
#modelDiv table {
    table-layout: fixed;
    width: 100%;
}

#modelDiv div#editObject table {
    width: initial;
    margin-left: 4em;
}

#modelDiv td, #modelDiv th {
    /* border: 1px solid blue; */
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
#modelDiv td.new, #modelDiv td.edit {
    width: 7em;
    overflow: initial;
    white-space: initial;
    text-overflow: initial;
}
td+td {
  width: auto;
}

</style>


<h3>Version 35.a</h3>
<h3>Previous versions</h3>
<br><a href=escene10.html>v 10</a> Include Subsystems
<br><a href=escene11.html>v 11</a> Subsystems with evalText for each subsystem
<br><a href=escene12.html>v 12</a> Arrays
<br><a href=escene13.html>v 13</a> Arrays con limites variables
<br><a href=escene15.html>v 15</a> Remove addDesign and create objects and arrays in updateMeasuresAPI
<br><a href=escene16.html>v 16</a> Change sx, xy, sz to lx, ly, lz
<br><a href=escene17.html>v 17</a> Corregir error de parametro en subsistema - Demo con cajoneras y cajones
<br><a href=escene18.html>v 18</a> Corregir error de parametro en subsistema - Ejemplo armario y 5 cajoneras
<br><a href=escene19.html>v 19</a> Ejemplo armario, para comprobar subsystem
<br><a href=escene19b.html>v 19b</a> Ejemplo armario, para comprobar sin subsystem
<br><a href=escene20b.html>v 20b</a> Corregir evalText para que solo haya un contexto y las variables del nivel (que no se repitan variables)
<br><a href=escene21.html>v 21</a> Pruebas armario
<br><a href=escene22.html>v 22</a> Ejemplo armario
<br><a href=escene23.html>v 23</a> Ejemplo armario con cajon con frontal y fondo
<br><a href=escene24.html>v 24</a> GUI for all objects
<br><a href=escene25.html>v 25</a> Load GLTF objects, forms to edit objects
<br><a href=escene26.html>v 26</a> Forms to edit parameters. Save file
<br><a href=escene27.html>v 27</a> Rotaciones desde el origen. Crear nuevo objeto y cambio de nombre
<br><a href=escene28.html>v 28</a> Rotation ZYX. Glass materials: glass1, glass2
<br><a href=escene29.html>v 29</a> Edición de materiales. BoxGeometry with lx, ly, lz
<br><a href=escene30.html>v 30</a> GLTF objects position. Puerta con rotación
<br><a href=escene31.html>v 31</a> Versión de ejemplo.
<br><a href=escene32.html>v 32</a> Campo type
<br><a href=escene33.html>v 33</a> Textura de cilindros proporcional
<br><a href=escene34.html>v 34</a> Triángulos
<br><a href=escene35.html>v 35</a> Extrusión
<br><a href=escene36.html>v 36</a> Formulario de materiales

  <script>
document.write("parameters: " + designObj.parameters.length);
document.write("pieces: " + designObj.pieces.length);
  </script>
</body></html>
<!-- Tareas

V- Editar parámetros de subsistemas
V- Quitar             setDefaultValues(objArray[i]); en createTable
V- Guardar JSON de solo la definición
V- Cargar JSON
V- Visualizar cambios de edición
V- Duplicar objeto de colección
V- Crear nuevo objeto
V- ejemplo puerta batiente
V- gltf, mover, rotar y escalar
V- Load GUI de subsistemas
V- step en GUI
v31
V- edit para parameters con type module (subsystem or object)
V- Limpiar Collection de código
v32
V- link a https://codebeautify.org/jsonviewer
V- decidir nombres de campos y de tipos de primitivas
V- ejemplo completo
v33
V- textura (uv) de cilindros escaladas - shapes, definidas por puntos, para extrusión
v35
- Formuario para editar materiales
- Guardar materiales
- environment mapping
- materiales con brillos
- materiales con normales
- otros materiales: metalico, blanco
- editor de materiales: 
    https://threejs.org/examples/#webgl_materials_displacementmap
    https://threejs.org/examples/#webgl_materials_physical_transmission
    https://threejs.org/examples/#webgl_materials_subsurface_scattering
    https://threejs.org/docs/#api/en/materials/MeshStandardMaterial
- tipos de primitivas
- decidir interface para seleccionar materiales de piezas
- crear un objeto a partir de otro: armario con decoración -> desde armario

- boton New para tipo de pieza (Box, Cylinder, Module, Gltf)
- extruxión
- bevels
- bezier:
    http://jrlazz.eu5.org/ggk/bezcurto.html
    file:///C:/Java/appengine-java-sdk-1.9.73/applications/cloth/html/cloth/bezier/test.html
- parametros publicos y privados (definir precio como parametro)
    
    
References and examples of three.js
- https://threejs.org/
- github: https://github.com/mrdoob/three.js
- https://stemkoski.github.io/Three.js/
- exporting materials from Blender to three.js: https://betterprogramming.pub/how-to-create-awesome-3d-graphics-for-your-website-using-three-js-blender-and-greensock-a834cb8a6f6e

- lil-gui: https://lil-gui.georgealways.com/

- mirar libro de arquitectura de three.js

    
-->
