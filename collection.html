<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../w3.css">
  <link rel="stylesheet" href="../family_Raleway.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <script type="text/javascript" src="https://npmcdn.com/parse/dist/parse.min.js"></script>
  <script type="text/javascript" type="text/javascript" src="../user.js"></script>
  <script>
// debug varialbes
var start_time = (new Date).getTime();
//printTime("start");
var console_flag = true;
var console_flag_time = true;
var noTextureFlag = false;
var user_rol;
var embed = false;
var orderId;
var collectionId;
var companyId;
/*
1 "rol_customer";
2 "rol_manufacturer";
3 "rol_advanced";
*/
user_rol = 3;


materialOptionsObj = {
  "materialOptions": [
    {
      "name": "materials ext",
      "materials": [
        {"material": "plywood6"},
        {"material": "wood_table"},
        {"material": "kitchen_wood"},
        {"material": "UV_6map"},
        {"material": "dice"}
      ]
    }
  ]
}

collection = {};

/*
window.onerror = function(message, url, line, col, error) {
    if (error.name == 'SyntaxError' || error.name == 'ReferenceError') {
//        alert("Error en campo de entrada");
        console.error('error message: ' + error.message + " at line: " + line + ", col: " + col);
        console.error('error: ' + error);
        if (lastElement != null) {
            lastElement.classList.add("error");
        } else {
            alert(error.message + " at line: " + line + ", col: " + col);
        }
    } else {
        alert(error.message);
        console.error('error: ' + error.message);
    }
    return true;
};
*/


async function saveToDatabase() {
    document.getElementById("status").innerHTML = "Saving ...";
    exportCollection();
    data = document.getElementById("jsonObj").value;
    params3 = {}
    params3.id = collectionId;
    params3.data = data;
    params3.name = document.getElementById("collectionName").value;
    params3.token = getCookie("confToken");
    const objectCollection = await Parse.Cloud.run('updateCollection', params3);
    console.log("Collection saved", objectCollection);
    //document.getElementById("status").innerHTML = "Saved";
    document.getElementById("status").innerHTML = objectCollection;
}

function saveFileAs() {
    exportCollection();
    // https://codepen.io/mmousawy/pen/wBbrKM?editors=1010
    var promptFilename = "collection.txt" 
        var textBlob = new Blob([document.getElementById("jsonObj").value],
          {type:'text/plain'});
        var downloadLink = document.createElement("a");
        downloadLink.download = promptFilename;
        downloadLink.innerHTML = "Download File";
        downloadLink.href = window.URL.createObjectURL(textBlob);
        downloadLink.click();
    delete downloadLink;
    delete textBlob;
}

function readFile() {
    //https://cssdeck.com/labs/7bx7mmcm
    document.getElementById('readFile').innerHTML = "Reading file ... " + document.getElementById("loadFile").files[0].name;
    var fileToLoad = document.getElementById("loadFile").files[0];

    var fileReader = new FileReader();
    fileReader.onload = function(fileLoadedEvent) 
    {
        var textFromFileLoaded = fileLoadedEvent.target.result;
        document.getElementById("jsonObj").value = textFromFileLoaded;
        document.getElementById('readFile').innerHTML = "File readed: " + document.getElementById("loadFile").files[0].name;
        document.getElementById("loadFile").value = "";
        loadJSON();
        init();
    };
    fileReader.readAsText(fileToLoad, "UTF-8");
}

    function gotoObject() {
        //const objectName = window.location.search.substring( 1 ) || 'armario';
        //const objectName = objectName;
        
        //document.getElementById(objectId).scrollIntoView()
        
        scrollOffset(objectId, -38.5)

    }

    function scrollOffset(id, offset) {
        const element = document.getElementById(id);
        const y = element.getBoundingClientRect().top + window.pageYOffset + offset;

        window.scrollTo({top: y, behavior: 'auto'});
    }
function loadJSON() {
    designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
    // initially, before January 2023, designArr was an object. Transformed then to an array. This is the conversion for the transitory period.
    if (!Array.isArray(designArr)) {
        convertObjectToArray();
    } else {
        designArr_final = designArr;
    }
    materialArr = JSON.parse(document.getElementById('jsonObj').value).materialArr;
    if (materialArr != null && materialArr.length > 0 && materialArr[0].id == null) {
        setMaterialsId();
    }
    setDesignObject();
    //init();
}

function setMaterialsId() {
    for (var i =0; i< materialArr.length; i++) {
        if (materialArr[i].id == null) {
            materialArr[i].id = materialArr[i].name.replaceAll(" ","_"); // + "_id";
            materialArr[i].name = materialArr[i].name + "_nm";  // temporal name when id added
        }
    }
}

function setDesignObject() {
    designObj = getArrayElementById(designArr_final, objectId);
    if (designObj != null) {  
        objectId   = designObj.id;
        objectName   = designObj.name;
    } else {  // if the objectId is not in the current collection
        designObj = getArrayElementById(designArr_final, objectId);
        if (designObj != null) {
            objectName   = designObj.name;
        } else {    // if the objectId is not in the current collection
            objectId   = designArr_final[0].id;
            objectName = designArr_final[0].name;
            designObj  = designArr_final[0];
        }
    }
}
function convertObjectToArray() {
    designArr_final = [];
    for (var prop in designArr) {
        if (Object.prototype.hasOwnProperty.call(designArr, prop)) {
            console.log(designArr[prop].name, designArr[prop]);
            designArr_final.push(designArr[prop]);
            if (designArr[prop].id == null) {
                designArr[prop].id = designArr[prop].name.replaceAll(" ","_"); // + "_id";
                designArr[prop].name = designArr[prop].name + "_no"; // temporal name when id added
            }

        }
    }
}
        
</script>
<script src="js/split.min.js"></script> <!-- https://github.com/nathancahill/split/tree/master/packages/splitjs -->

<div id='renderDiv'></div>
<div id='materialPanel'></div>
<div id='manufacturer_div'>
<!--
<button onclick="newObject()">Create New Object</button>
<button onclick="resetEditor()">Reset Editor</button>
-->
<!-- <a id=collectionsList href='login.html' >Collections</a> -->
<div class="split">
  <div id='modelDiv'></div>
  <div id='renderColumnDiv'>
    <div id='renderArea'></div>
  </div>
</div>
<div id='fileDiv'></div>
<br>
<div id='experimentalDiv'>
<input id="collectionName_old"/> 
<button onclick="saveToDatabase()">Save (to Database)</button>
<button onclick="saveFileAs()">Export to file</button>
<button style="width:120px; height:30px;" onclick="document.getElementById('loadFile').click()">Import file</button>
<!--<input id="loadFile" onInput="readFile()" type="file" />-->
<input id="loadFile" onInput="readFile()" type="file" style="display:none"/>
<span id='readFile'></span>
<br>
<button onclick="exportCollection(), setTextAreaSize()">Show JSON</button>
<button onclick="loadJSON()">Load JSON</button>

<textarea ROWS=1 COLS=2 id='jsonObj_old'>
{"materialArr":[{"name":"default","color_r":0.45,"color_g":0.72,"color_b":0.96,"emissive_r":0.33,"emissive_g":0.51,"emissive_b":0.66,"roughness":0.109,"metalness":0.35,"reflectivity":0.18,"clearcoat":0,"clearcoatRoughness":0,"transparent":true,"opacity":0.78,"diffuseMap":false,"normalFactor":1,"envMapIntensity":0.94,"ior":1.16,"wireframe":false},{"name":"ground","size_x":"0.001","size_y":"0.001","color_r":"0.5","color_g":"0.5","color_b":"0.5","diffuseMap":false},{"name":"background","color_r":0.6,"color_g":0.6,"color_b":0.6,"diffuseMap":true},{"name":"UV_map","diffuseMap":true}],"designArr":{"First Object":{"name":"First Object","parameters":[],"pieces":[]}}}
</textarea>
<script>
textareaContent = '{"materialArr":[{"name":"default","color_r":0.45,"color_g":0.72,"color_b":0.96,"emissive_r":0.33,"emissive_g":0.51,"emissive_b":0.66,"roughness":0.109,"metalness":0.35,"reflectivity":0.18,"clearcoat":0,"clearcoatRoughness":0,"transparent":true,"opacity":0.78,"diffuseMap":false,"normalFactor":1,"envMapIntensity":0.94,"ior":1.16,"wireframe":false},{"name":"ground","size_x":"0.001","size_y":"0.001","color_r":"0.5","color_g":"0.5","color_b":"0.5","diffuseMap":false},{"name":"background","color_r":0.6,"color_g":0.6,"color_b":0.6,"diffuseMap":true},{"name":"UV_map","diffuseMap":true}],"designArr":{"First Object":{"name":"First Object","parameters":[],"pieces":[]}}}'
</script>
<a href='https://codebeautify.org/jsonviewer' target=_blank>See JSON beautify</a> <a href='bezier.html' target=_blank>Bezier curves</a>
<div>url for final user: <span id="url_final_old"></span></div>
<div>Share: <input id="url_share_old" size="150"></div>
</div> <!--experimentalDiv-->
</div>



  <style id="compiled-css" type="text/css">
body {
      margin: 0;
}

.lil-gui.autoPlace {
    top: 40px;
}
    /* EOS */
  </style>

  <script id="insert"></script>


</head>
<body>

<!-- Navbar (sit on top) -->
<div id="navbar" class="w3-top">
  <div class="w3-bar w3-white w3-card" id="myNavbar">
    <a href="/model3fab" class="w3-bar-item w3-button w3-wide">model3fab</a>
    <span  class="w3-bar-item">Collection: </span>
    <input id="collectionName" class="w3-bar-item w3-border-small"/> 
    
    <div class="w3-dropdown-hover w3-hide-small">
        <button class="w3-button" title="Notifications">File <i class="fa fa-caret-down"></i></button>     
        <div class="w3-dropdown-content w3-card-4 w3-bar-block">
          <a href="#" onclick="saveFileAs()" class="w3-bar-item w3-button">Export</a>
          <a href="#" onclick="document.getElementById('loadFile').click()" class="w3-bar-item w3-button">Import</a>
          <a href="#" onclick="exportCollection(), document.getElementById('formJSONModal').style.display='block'" class="w3-bar-item w3-button">Show JSON</a>
          <a href="#" onclick="loadJSON(), init();" class="w3-bar-item w3-button">Load JSON</a>
          <a href="#" onclick="document.getElementById('formEmbed').style.display='block'" class="w3-bar-item w3-button">Embed</a>
          <a href="#" onclick="resetEditor()" class="w3-bar-item w3-button">Reset Editor</a>

          <!-- <a href="#" onclick="document.getElementById('formJSONModal').style.display='block'" class="w3-bar-item w3-button">Modal</a>-->
        </div>
    </div>
    <a id=collectionsList href='login.html' class="w3-bar-item w3-button">Collections</a>
    <a href="#" onclick="saveToDatabase()" class="w3-bar-item w3-button">Save</a>
    <a href="#renderDiv" class="w3-bar-item w3-button"><i class="fa fa-arrow-up"></i>Top</a>
    <a href="javascript:scrollOffset('Materials', -38.5)" class="w3-bar-item w3-button"><i class="fa fa-paint-brush"></i> Materials</a>
    <a href="javascript:gotoObject()" class="w3-bar-item w3-button"><i class="fa fa-cube"></i> Object</a>
    <span class="w3-bar-item" style="padding-right: 0px;"><i class="fa fa-tachometer"></i></span><span  id="status" class="w3-bar-item">Status</span>
    <!-- Right-sided navbar links -->
    <!-- 
    <div class="w3-right w3-hide-small">
      <a href="#pricing" class="w3-bar-item w3-button"><i class="fa fa-table"></i> Planes</a>
      <a href="#contact" class="w3-bar-item w3-button"><i class="fa fa-envelope"></i> Contacto</a>
      <a href="Configurator/login.html#contact" class="w3-bar-item w3-button"><i class="fa fa-user"></i> Login</a>
      <a href="Configurator/registerCompany.html#contact" class="w3-bar-item w3-button"><i class="fa fa-user-plus"></i> Registro</a>
    -->
      <!--  other icons fa-group -->
    </div>
    <!-- Hide right-floated links on small screens and replace them with a menu icon -->

    <a href="javascript:void(0)" class="w3-bar-item w3-button w3-right w3-hide-large w3-hide-medium" onclick="w3_open()">
      <i class="fa fa-bars"></i>
    </a>
  </div>
</div>

<!-- JSON Modal -->
  <div id="formJSONModal" class="w3-modal">
    <div class="w3-modal-content w3-animate-top w3-card-4">
      <header class="w3-container w3-teal w3-center w3-padding-32"> 
        <span onclick="document.getElementById('formJSONModal').style.display='none'" 
       class="w3-button w3-teal w3-xlarge w3-display-topright">&times;</span>
        <h2 class="w3-wide"><i class="fa fa-file w3-margin-right"></i>JSON</h2>
      </header>
      <div class="w3-container">
        <p><label>JSON file</label></p>
        <textarea rows="10" cols="80" id='jsonObj' class="w3-input w3-border" type="text" >
{"materialArr":[{"name":"default","color_r":0.45,"color_g":0.72,"color_b":0.96,"emissive_r":0.33,"emissive_g":0.51,"emissive_b":0.66,"roughness":0.109,"metalness":0.35,"reflectivity":0.18,"clearcoat":0,"clearcoatRoughness":0,"transparent":true,"opacity":0.78,"diffuseMap":false,"normalFactor":1,"envMapIntensity":0.94,"ior":1.16,"wireframe":false},{"name":"ground","size_x":"0.001","size_y":"0.001","color_r":"0.5","color_g":"0.5","color_b":"0.5","diffuseMap":false},{"name":"background","color_r":0.6,"color_g":0.6,"color_b":0.6,"diffuseMap":true},{"name":"UV_map","diffuseMap":true}],"designArr":{"First Object":{"name":"First Object","parameters":[],"pieces":[]}}}
        </textarea>
        <button class="w3-button w3-block w3-teal w3-padding-16 w3-section w3-right" onclick="loadJSON(), document.getElementById('formJSONModal').style.display='none', init()">Load JSON <i class="fa"></i></button>
        <button class="w3-button w3-block w3-red  w3-padding-16 w3-section w3-right" onclick="document.getElementById('formJSONModal').style.display='none'">Close <i class="fa fa-remove"></i></button>
        <p class="w3-right">Tool: <a href="https://codebeautify.org/jsonviewer" target="_blank">See JSON beautify</a></p>
      </div>
    </div>
  </div>

<!-- Embed Modal -->
  <div id="formEmbed" class="w3-modal">
    <div class="w3-modal-content w3-animate-top w3-card-4">
      <header class="w3-container w3-teal w3-center w3-padding-32"> 
        <span onclick="document.getElementById('formEmbed').style.display='none'" 
       class="w3-button w3-teal w3-xlarge w3-display-topright">&times;</span>
        <h2 class="w3-wide"><i class="fa fa-file w3-margin-right"></i>JSON</h2>
      </header>
      <div class="w3-container">
        <p><label>JSON file</label></p>
        <div>url for final user: </div>
        <div id="url_final"></div>
        <BR>
        <div>Embed: 
        </div>
          <textarea id="url_share"  rows="4" cols="80" class="w3-input w3-border" type="text"></textarea>
        <button class="w3-button w3-block w3-red  w3-padding-16 w3-section w3-right" onclick="document.getElementById('formEmbed').style.display='none'">Close <i class="fa fa-remove"></i></button>
      </div>
    </div>
  </div>

<script>

function parse_query_string(query) {
  var vars = query.split("&");
  var query_string = {};
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    var key = decodeURIComponent(pair[0]);
    var value = decodeURIComponent(pair[1]);
    // If first entry with this name
    if (typeof query_string[key] === "undefined") {
      query_string[key] = decodeURIComponent(value);
      // If second entry with this name
    } else if (typeof query_string[key] === "string") {
      var arr = [query_string[key], decodeURIComponent(value)];
      query_string[key] = arr;
      // If third or later entry with this name
    } else {
      query_string[key].push(decodeURIComponent(value));
    }
  }
  return query_string;
}

    Parse.serverURL = 'https://parseapi.back4app.com';
    Parse.initialize('3BvaDwQZMh46667Meslf8E2DuUWKjb5RBiAuXNxv', 'CRR8qDBiWK1UG04hyxeKIRoZKc3fh3g0nxTpXdKN');

    async function loadCollectionFromOrder(order) {
        params3 = {}
        params3.id = order;
        const objectOrder = await Parse.Cloud.run('readOrderById', params3);
        console.log("objectOrder", objectOrder);
        objectId = objectOrder.objectId;
        collectionId = objectOrder.collectionId;
        objectPOM = JSON.parse(objectOrder.data);
        setCollectionData(objectOrder.collection);
    }
    async function loadCollectionFromDatabase(collection) {
        params3 = {}
        params3.id = collection;
        const objectCollection = await Parse.Cloud.run('readCollectionById', params3);
        console.log("objectCollection", objectCollection);
        setCollectionData(objectCollection);
    }
    function setCollectionData(objectCollection) {
        document.getElementById("collectionName").value = objectCollection.name;
        companyId = objectCollection.company;
        document.getElementById("collectionsList").href = "login.html?company=" + objectCollection.company;
        document.getElementById('jsonObj').value = objectCollection.data;
        loadJSON();
        init();
    }


defaultObject = "First Object";

designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
materialArr = JSON.parse(document.getElementById('jsonObj').value).materialArr;

var objectId;
var objectName;  // the reference must be the objectId
var designObj;
var objectPOM;
// root = window.location.pathname.substr(1,window.location.pathname.indexOf("/",1)-1)
var query = window.location.search.substring(1);
var qs = parse_query_string(query);
if (qs.object != null) {
    objectId = qs.object;
}
if (qs.rol != null) {
    user_rol = qs.rol;
    if (user_rol == 1) {
        console_flag = false;
        console_flag_time = false;
    }
}
if (qs.embed != null) {
    embed = true;
}
if (qs.notexture != null) {
    noTextureFlag = true;
}
if (qs.collection != null) {
//    loadCollectionFromDatabase(qs.collection);
    collectionId = qs.collection;
}
if (qs.order != null) {
    orderId = qs.order;
}
//setDesignObject();
//designObj = designArr[objectName];

//materialsObj = materialArr;
var renderer;
var scene;
var camera;
var light1;
var light2;
var light3;
var light4;
var hemiLightObject;
var lightHelperGroup;
var bottomSpace = 24;  // pixels at the bottom
var rendererWidth;
var rendererHeight;

let gui;
let guiParametersFolder;
var POM;

var THREE;
var CSG;
var API = {
    offsetX: 0,
    offsetY: 0,
    repeatX: 1.,
    repeatY: 1.,
    rotation: 0,  //Math.PI / 4, // positive is counter-clockwise
    centerX: 0.0,
    centerY: 0.0,
    renders: 0,
    Environment: "background color",
};
var shadowFlag = true;
var environmentFlag = true;
var autosaveFlag = true;
var transparentControlFlag = false;
var lastElement;
var createdLights = false;
var defaultMaterial;
var materialData;
var materialGui;
var material_UV;
var materialOverride = null;
var flagSetMaterialAll = false;

loaders = {};

// implement the if condition to be used in a formula
function condition(cond, trueValue, falseValue) {
    if (cond) {
        if (isNaN(trueValue)) {
            return eval(trueValue);
        } else {
            return trueValue;
        }
    } else {
        if (isNaN(falseValue)) {
            return eval(falseValue);
        } else {
            return falseValue;
        }
    }
}

//implement of ramp function
  //  1               --------
  //                 /        \
  //                /          \
  //               /            \
  //  0 -----------              -----------
  //              a   b      c   d          
  
function ramp(a,b,c,d,t) {
  if (t <= a) return 0;
  else if (t <= b) return (t - a)/(b-a);
  else if (t < c) return 1;
  else if (t <= d) return 1 - (t - c)/(d-c);
  else return 0;
}
</script>



<script>
    document.getElementById('jsonObj').value = textareaContent;
    
    const settings = {
        debug: false,
        axes: true,
        fov: 50.0,     // https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.fov
        ground: true,
        fog: true,
        UV: false,
        background: true,
        blurriness: 0.3,  // will work with threejs version 146, currently using 141
        env: true,
        pointLightFactor: 1.0,
        directionalLightFactor: 1.0,
        hemiLightFactor: 1.0,
        exposure: 1.0,
        hemiLight: false,
        shadow: shadowFlag,
        noTexture: noTextureFlag,
        autosave: autosaveFlag,
        transparentControl: transparentControlFlag,
    };
</script>
    
<script type="importmap">
    {
        "imports": {
            "three": "./three/build/three.module.js"
        }
    }
</script>
<script>
//    if (designObj != null) {
//        init(true);
//    }
    //showForm();

</script>

<script type="module">//<![CDATA[

function loadCollection() {
    if (orderId != null) {
        loadCollectionFromOrder(orderId);
    } else if (collectionId != null) {
        loadCollectionFromDatabase(qs.collection);
    } else {
/*
    designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
    if (!Array.isArray(designArr)) {
        convertObjectToArray();
    } else {
        designArr_final = designArr;
    }
    materialArr = JSON.parse(document.getElementById('jsonObj').value).materialArr;
    if (materialArr != null && materialArr.length > 0 && materialArr[0].id == null) {
        setMaterialsId();
    }
    setDesignObject();
*/
    loadJSON();
    init();
    }
}

    import * as THREE_import from 'three';
    THREE = THREE_import;

    import { GUI } from './jsm/libs/lil-gui.module.min.js';
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import CSG_import from "./jsm/libs/three-csg.js"
    CSG = CSG_import;

    loaders.GLTFLoader = GLTFLoader;


    let mesh;  // camera, renderer set global to change position in createForm

    flagSetMaterialAll = settings.UV;

    var geometry;
    var axesHelper;
    var groundMesh;
    var evalText;
    var guiPieces = null;

    var textureEnv;
    /*
    */
    defaultMaterial = new THREE.MeshPhysicalMaterial( { color: 0xffffff } );
    defaultMaterial.diffuseMap = true;

    loadCollection();

    export function init(loadMaterialsFlag) {
        printTime("init");

        var url_final = document.getElementById("url_final");
        var url_finalStr;
        if (objectPOM == null) {
            url_finalStr = window.location.origin + window.location.pathname + "?collection=" + collectionId + "&object=" + objectId + "&rol=1&embed";
        } else { // url to order
            url_finalStr = window.location.origin + window.location.pathname + "?order=" + orderId + "&rol=1&embed";
        }
        url_final.innerHTML = "<a target='_blank' href='" + url_finalStr + "'>" + url_finalStr + "</a>";
        url_share.value = "<iframe id='iframe01' width='100%' height='500px' src='" + url_finalStr + "'>" + "'</iframe>";
        
        createdLights = false;
        settings.UV = false;
        /*
        for (var i =0; i< designObj.parameters.length; i++) {
            if (designObj.parameters[i].type == "options") {
                //API[designObj.parameters[i].name] = designObj.parameters[i].options[0][1];
                if (designObj.parameters[i].default != null) {
                    API[designObj.parameters[i].name] = (designObj.parameters[i].default);
                } else {
                    if (designObj.parameters[i].options.length >= 1) {
                        API[designObj.parameters[i].name] = designObj.parameters[i].options[0][1];  // first option
                    } else {
                        API[designObj.parameters[i].name] = "''";
                    }
                }
            } else {
                API[designObj.parameters[i].name] = Number(designObj.parameters[i].default);
            }
        }
        */

        renderer = new THREE.WebGLRenderer({ antialias: true});
        //renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.LinearToneMapping;
        renderer.toneMappingExposure = settings.exposure;
        renderer.outputEncoding = THREE.sRGBEncoding;
        printTime("renderer created");
        lightHelperGroup = new THREE.Group();
        if (shadowFlag) {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
          //renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        } else {
            renderer.shadowMap.enabled = false;
        }
        renderer.setPixelRatio( window.devicePixelRatio );
        rendererWidth = window.innerWidth;
        rendererHeight = window.innerHeight - bottomSpace;
        renderer.setSize( rendererWidth, rendererHeight );
        printTime("renderer.setSize");
        var divEl = document.getElementById("renderDiv");
/*
        if (divEl == null) {  // create node or delete content node
            divEl = document.createElement("DIV");
            divEl.setAttribute("id", "renderDiv");
//            document.appendChild( divEl);
            document.insertBefore(divEl, document.firstChild);
        } else {
            divEl.textContent = ''
        }
*/
        if (divEl != null) {  // create node or delete content node
            divEl.remove();
        }
        divEl = document.createElement("DIV");
        divEl.setAttribute("id", "renderDiv");
//            document.appendChild( divEl);
        document.body.insertBefore(divEl, document.body.firstChild);
        divEl.appendChild( renderer.domElement );

        scene = new THREE.Scene();
        printTime("scene");
        
        scene.add(lightHelperGroup);
        camera = new THREE.PerspectiveCamera( settings.fov, rendererWidth / rendererHeight, .01, 1000 );
        camera.position.set( 4, 5, 1.6 );
        camera.up.set(0,0,1)   // z up (https://stackoverflow.com/questions/44630265/how-can-i-set-z-up-coordinate-system-in-three-js)
        scene.add( camera );

        const controls = new OrbitControls( camera, renderer.domElement );
        printTime("OrbitControls");
        controls.addEventListener( 'change', render );
        controls.minDistance = 0.1;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2 * 1.8;

        // Cube
        var textureCube;
        const cubeTextureLoader = new THREE.CubeTextureLoader();
      //const ldrUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'];
//        loader.setPath( 'textures/cube/pisa/' );
//        loader.setPath( 'textures/cube/pisa_Y/' );
        cubeTextureLoader.setPath( 'textures/cube/Park2/' );
//        loader.setPath( 'textures/cube/DallasW/' );
      //const ldrUrls = [ 'px2.png', 'nx2.png', 'py2.png', 'ny2.png', 'pz2.png', 'nz2.png'];
        //const ldrUrls = [ 'i_0.png', 'i_1.png', 'i_2.png', 'i_3.png', 'i_4.png', 'i_5.png'];
        const ldrUrls = [ 'i_0.jpg', 'i_1.jpg', 'i_2.jpg', 'i_3.jpg', 'i_4.jpg', 'i_5.jpg'];
        //const ldrUrls = [ 'Dice-Blue-1.png', 'Dice-Blue-2.png', 'Dice-Blue-3.png', 'Dice-Blue-4.png', 'Dice-Blue-5.png', 'Dice-Blue-6.png'];
        //loader.setPath( 'images/' );

        if (!noTextureFlag) {
            textureCube = cubeTextureLoader.load( ldrUrls );
            //textureCube.rotation = 1.6;
            textureCube.encoding = THREE.sRGBEncoding;
        }


        //scene.nbackground = textureCube;
        //scene.texture = textureCube;

        //var sphereMaterial = new THREE.MeshPhysicalMaterial( { envMapIntensity: 3,premultipliedAlpha: true,specularIntensity: 1, envMap: textureCube } );
        //var sphereMaterial1 = new THREE.MeshPhysicalMaterial( { envMap: textureCube } );
        
        //textureEnv = textureCube;
        /*
        */

        /*

        // Equirectangular
        const textureLoader = new THREE.TextureLoader();
        //var textureEquirec = textureLoader.load( 'examples/textures/2294472375_24a3b8ef46_o.jpg' );
        var textureEquirec = textureLoader.load( 'textures/IndoorHDRI001_1K-TONEMAPPED.jpg' );
        //var textureEquirec = textureLoader.load( 'examples/textures/equirectangular/venice_sunset_1k.hdr' );

// Pruebas rotacion Envmap
//        textureEquirec.matrixAutoUpdate = true 
//        textureEquirec.rotation = Math.PI /180. * 120;					// I don't understand how rotate = Math.PI /180. * 120;
//        textureEquirec.needsUpdate = true;
        textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
        textureEquirec.encoding = THREE.sRGBEncoding;
        
        //scene.background = textureEquirec;
        //scene.texture = textureEquirec;

        //var sphereMaterial2 = new THREE.MeshPhysicalMaterial( { envMap: textureEquirec } );
        //sphereMaterial2.envMap = textureEquirec;
        
        //var sphereMaterial = sphereMaterial2;
        */
        textureEnv = textureCube;


        var meshMaterial;
        //if (loadMaterialsFlag) {
            loadMaterials();
        //}
        printTime("loadMaterials");
        //        addDesign(scene, designObj);
        
        axesHelper = new THREE.AxesHelper( 4 );
        axes();
        scene.add( axesHelper );
        
        groundMesh = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), materialArr[1].material );
        //materialArr[1].material.map_backup.repeat.set( 1000, 1000);
        groundMesh.position.z = -0.001;
        if (shadowFlag) {
            groundMesh.receiveShadow = true;
        } else {
            groundMesh.receiveShadow = false;
        }
        scene.add( groundMesh );

        initGui();
        printTime("initGui");

        ground();
        fog();
        setBackground();
        printTime("ground");
        scene.backgroundBlurriness = settings.blurriness;

        updateMeasures();  // comment to improve speed while working in html forms
        printTime("updateMeasures 1");
        //updatePOMformulas(POM, 0);               // to update formulas with values
        uptadeControllers(guiParametersFolder);  // to update formulas with values
        printTime("uptadeControllers");
        updateMeasures();  // comment to improve speed while working in html forms
        printTime("updateMeasures 2");
        updateUvTransform();
        printTime("uptadeUvTransform");
        
        // Create lights if are not created
        if (!createdLights) {
            if (console_flag) console.log("Creating default lights");
            light1 = new THREE.PointLight( 0xffffff, 1.0, 10, 2 );
            if (shadowFlag) {
                light1.castShadow = true;
            } else {
                light1.castShadow = false;
            }
            light1.position.x = 1;
            light1.position.y = 2;
            light1.position.z = 1.5;
            scene.add( light1 );
            light2 = new THREE.PointLight( 0xffffff, 1.0, 10, 2  );
            if (shadowFlag) {
                light2.castShadow = true;
            } else {
                light2.castShadow = false;
            }
            light2.position.x = 3;
            light2.position.y = 4;
            light2.position.z = 1;
            scene.add( light2 );
            light3 = new THREE.DirectionalLight( 0xffffff, 1.0 );
            /*
            if (shadowFlag) {
                light3.castShadow = true;
            } else {
                light3.castShadow = false;
            }
            */

            //light3.shadow.camera.near = 5;
            //light3.shadow.camera.far = 10;
            
            light3.position.x = 4;
            light3.position.y = -5;
            light3.position.z = 3;
            scene.add( light3 );
            //const helperLight3 = new THREE.DirectionalLightHelper( light3, 0.5 );
            //lightHelperGroup.add( helperLight3 );
            light4 = new THREE.DirectionalLight( 0xffffff, 1.0 );
            light4.position.x = -2;
            light4.position.y = -2;
            light4.position.z = .5;
            scene.add( light4 );
        }
        hemiLightObject = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
        //hemiLightObject.color.setHSL( 0.6, 1, 0.6 );
        //hemiLightObject.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLightObject.position.set( 0, 50, 0 );
        hemiLightObject.visible = settings.hemiLight;
        scene.add( hemiLightObject );
        
        printTime("createLights");

        //printModelTable("model", designObj);
        if (user_rol >= 2) {
            showForm();
            var manufacturer_div =document.getElementById("manufacturer_div");
            manufacturer_div.style.display = "initial";
            var version =document.getElementById("version");
            version.style.display = "initial";
            expandPanel(document.getElementById(objectId), true)
        }
        if (!embed) {
            var navbar_div =document.getElementById("navbar");
            navbar_div.style.display = "initial";
        }
        printTime("showForm");

        for (var i =0; i< materialArr.length; i++) {
            //if (materialArr[i].type == "arrayEnvmap" || materialArr[i].type == "array" || true) {
            if (true) {

                copyMaterialPropertiesFromModelToEditor(materialArr[i], materialGui, false);
                materialEdit = materialArr[i].material
                updatePhysicalMaterial();
            }
        }
        printTime("copyMaterial");

        render();
        printTime("render");

        window.addEventListener( 'resize', onWindowResize );

    }  // init
    
    function loadMaterials() {
        for (var i =0; i< materialArr.length; i++) {
            if (console_flag) console.log("Material: " + materialArr[i].name);
            if (materialArr[i].type == "single_***") {
                var texture = new THREE.TextureLoader().load( materialArr[i].texture, function ( texture ) {
                    render();
                } );
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually
                //var meshMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, map: texture } );
                var meshMaterial = new THREE.MeshStandardMaterial( { map: texture });
                //var meshMaterial = new THREE.MeshBasicMaterial( { map: texture } );
                //material_UV = material;  // tmp
                materialArr[i].material = meshMaterial;
            /*
            } else if (materialArr[i].type == "glass1") {
                  const meshMaterial = new THREE.MeshPhysicalMaterial( {
                    map: null,
                    color: 0xfffffa,
                    metalness: 0,
                    roughness: 0,
                    opacity: 0.25,
                    side: THREE.BackSide,
                    transparent: true,
                    envMapIntensity: 10,
                    premultipliedAlpha: true
                } );
                materialArr[i].material = meshMaterial;
            } else if (materialArr[i].type == "glass2") {
                var meshMaterial = new THREE.MeshPhysicalMaterial({
                    metalness: .9,
                    roughness: .05,
                    envMapIntensity: 0.9,
                    clearcoat: 1,
                    transparent: true,
                    // transmission: .95,
                    opacity: .5,
                    reflectivity: 0.2,
                    //refractionRatio: 0.985,
                    ior: 0.9,
                    side: THREE.BackSide,
                    })
                materialArr[i].material = meshMaterial;
            */
            } else if (materialArr[i].type == "envmap_***") {
          
                materialArr[i].material = sphereMaterial;
            } else if (materialArr[i].type == "None array_***") {
            //} else if (materialArr[i].type == "arrayEnvmap" || materialArr[i].type == "array" || true) {
            } else if (true) {
                var texture = null;
                if (materialArr[i].texture != null && materialArr[i].texture != "") {
                    texture = loadTexture(materialArr[i], materialArr[i].texture);
                }
                var normalMap;
                if (materialArr[i].normalMap != null && materialArr[i].normalMap != "") {
                    normalMap = loadTexture(materialArr[i], materialArr[i].normalMap);
                } else {
                    normalMap = null;
                }
                var roughnessMap;
                if (materialArr[i].roughnessMap != null && materialArr[i].roughnessMap != "") {
                    roughnessMap = loadTexture(materialArr[i], materialArr[i].roughnessMap);
                } else {
                    roughnessMap = null;
                }
                var side;
                if (materialArr[i].side == 1) {
                    side = THREE.BackSide;
                } else {
                    side = THREE.FrontSide;
                }
                var vector2D = new THREE.Vector2( 4, 4 );
                var environmentTexture;
                if (environmentFlag) {
                    environmentTexture = textureEnv;
                    scene.environment = textureEnv;
                } else {
                    environmentTexture = null;
                    scene.environment = null;
                }
                meshMaterial = new THREE.MeshPhysicalMaterial({
                    metalness: .3,
                    roughness: .95,
                    roughnessMap: roughnessMap,
                    envMapIntensity: 0,
                    clearcoat: 1,
                    map: texture,
                    transparent: false,
                    // transmission: .95,
                    opacity: 1,
                    reflectivity: 0.2,
                    //refractionRatio: 0.985,
                    ior: 0.9,
                    //side: THREE.BackSide,
                    side: side,
                    //envMap: environmentTexture,  // removed envMap, so it takes the property from scene.environment 78.02
                    normalMap: normalMap,
                    normalScale: vector2D,
                    })
                    
                meshMaterial.map_backup = texture;
                materialArr[i].material = meshMaterial;
                /*
                if (materialArr[i].transparent != null && eval(materialArr[i].transparent) == false) {
                    materialArr[i].transparent = false;
                } else {
                    materialArr[i].transparent = true;
                }
                */
                if (materialArr[i].diffuseMap != null && eval(materialArr[i].diffuseMap) == false) {
                    materialArr[i].diffuseMap = false;
                } else {
                    materialArr[i].diffuseMap = true;
                }
                if (materialArr[i].diffuseMap == false) {
                    meshMaterial.map = null;
                    meshMaterial.needsUpdate = true;;
                }

                // load material from model 
                //copyMaterialPropertiesFromModelToEditor(materialArr[i].material, materialGui);
                //updatePhysicalMaterial();
                
            } else {  // array
                if (console_flag) console.log("Material type not defined: " + materialArr[i].type);
            }
            if (materialArr[i].name == "UV_6map") {
                material_UV = meshMaterial;
            }
        }
    }  // loadMaterials


    //import { init } from ".";
    window.init = init;
    window.updateMeasures = updateMeasures;
    
    function showForm() {
        var modelDiv = document.getElementById('modelDiv')
        modelDiv.textContent = ''
        
        printMaterialTable();
        printObjectsTable(); //***
//        for (var prop in designArr) {
//            if (Object.prototype.hasOwnProperty.call(designArr, prop)) {
        for (var i =0; i< designArr_final.length; i++) {
            //set id for design objects without id - moved to convertObjectToArray()
            printModelTable(designArr_final[i]);
        }
        createExpandPanels();
        // button New Object
        var buttonNewObject = document.createElement("BUTTON");
        buttonNewObject.setAttribute("onClick", "newObject()");
        var textNewObject = document.createTextNode("New Object");
        buttonNewObject.appendChild(textNewObject);
        modelDiv.appendChild(buttonNewObject);

    }
    function visibility(arg) {
        if (console_flag) console.log("visibility: " + arg + " " + this.property);
        //getPiece(this.property).array[0].mesh.visible = arg;
        API[this.property + 'array_index'].mesh.visible = arg;
        render();
    }
    /*function createSimplePoint(THREE) {
        var geometry = new THREE.BufferGeometry();
        const vertices = [];
        vertices.push(new THREE.Vector3( 0, 0, 0));
        //geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
        var dot = new THREE.Points(geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );
        return dot;
    }
    */
    function loadTexture(materialElement, file) {
        if (noTextureFlag) return null;
    
//        if (console_flag) console.log("loadTexture: " + (new Date().toLocaleTimeString()) + " " + file);
        printTime("loadTexture " + file);
        var texture = new THREE.TextureLoader().load( file,function (texture) {
            //meshMaterial.needsUpdate = true;
            //console.log("texture loaded: " + (new Date().toLocaleTimeString()) + " " + file);
            printTime("texture loaded: " + file);
            render();
        } )
        //var meshMaterial = new THREE.MeshBasicMaterial( { map: texture });
        //var meshMaterial = new THREE.MeshStandardMaterial( { map: texture });
        
        //var meshMaterial = new THREE.MeshStandardMaterial( { color: 0xffffff, map: texture } );
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture.matrixAutoUpdate = false;
        texture.material = materialElement;
        updateUvTransformTexture(texture);
        return texture;
    }

/*
    const envMapKeys = getObjectsKeys( envMaps );
    const envMapKeysPBR = envMapKeys.slice( 0, 2 );
    const diffuseMapKeys = getObjectsKeys( diffuseMaps );
    const roughnessMapKeys = getObjectsKeys( roughnessMaps );
    const matcapKeys = getObjectsKeys( matcaps );
    const alphaMapKeys = getObjectsKeys( alphaMaps );
    const gradientMapKeys = getObjectsKeys( gradientMaps );
*/

    function handleColorChange( color, converSRGBToLinear = false ) {

        return function ( value ) {

            if ( typeof value === 'string' ) {

                value = value.replace( '#', '0x' );

            }
            color.setHex( value );

            if ( converSRGBToLinear === true ) color.convertSRGBToLinear();
            updatePhysicalMaterial();
        };

    }
    function guiMeshPhysicalMaterial( gui, material) { //, geometry ) {

        materialData = {
            color: material.color.getHex(),
            emissive: material.emissive.getHex()
            //envMaps: envMapKeys[ 0 ],
            //map: diffuseMapKeys[ 0 ],
            //roughnessMap: roughnessMapKeys[ 0 ],
            //alphaMap: alphaMapKeys[ 0 ]
        };
        var folder = null;
        if (user_rol >= 2) {

            folder = gui.addFolder( 'Material properties' );

            var materialsAPI = {};
            for (var i =0; i< materialArr.length; i++) {
                materialsAPI[materialArr[i].name] = materialArr[i].id;
            }
            API["Materials"] = materialArr[0].name;
            folder.add( API, "Materials", materialsAPI).onChange( setMaterial);
            
            folder.addColor( materialData, 'color' ).onChange( handleColorChange( material.color, false ) );
            folder.addColor( materialData, 'emissive' ).onChange( handleColorChange( material.emissive, false ) );

            folder.add( material, 'roughness', 0, 1 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'metalness', 0, 1 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'reflectivity', 0, 1 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'clearcoat', 0, 1 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'clearcoatRoughness', 0, 1 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            // geometry //folder.add( material, 'flatShading' ).onChange( needsUpdate( material, geometry ) );
            folder.add( material, 'transparent' ).onChange( updatePhysicalMaterial );
            folder.add( material, 'opacity', 0, 1 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'diffuseMap' ).onChange( updatePhysicalMaterial );
            folder.add( material, 'normalFactor', 0, 5 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'envMapIntensity', 0, 3 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'ior', 0, 3 ).step( 0.01 ).onChange( updatePhysicalMaterial );
            folder.add( material, 'wireframe' ).onChange( updatePhysicalMaterial );
            // geometry //folder.add( material, 'vertexColors' ).onChange( needsUpdate( material, geometry ) );
            // geometry //folder.add( material, 'fog' ).onChange( needsUpdate( material, geometry ) );
            //folder.add( materialData, 'envMaps', envMapKeysPBR ).onChange( updateTexture( material, 'envMap', envMaps ) );
            //folder.add( materialData, 'map', diffuseMapKeys ).onChange( updateTexture( material, 'map', diffuseMaps ) );
            //folder.add( materialData, 'roughnessMap', roughnessMapKeys ).onChange( updateTexture( material, 'roughnessMap', roughnessMaps ) );
            //folder.add( materialData, 'alphaMap', alphaMapKeys ).onChange( updateTexture( material, 'alphaMap', alphaMaps ) );
            // TODO metalnessMap
        }
        return folder;

    }

    function updateMaterial(){
        updateMaterialDesign(designObj);
        render();
    }
    function updateMaterialDesign(updateMaterialDesignObj){
        if (console_flag) console.log("updateMaterial");
        for (var i =0; i< materialOptionsObj.materialOptions.length; i++) {
            if (console_flag) console.log(API[materialOptionsObj.materialOptions[i].name]);
        }
        for (var i = 0; i< updateMaterialDesignObj.pieces.length; i++) {
            if ('subsystem' in updateMaterialDesignObj.pieces[i]) {
                //updateMaterialDesign(designArr[updateMaterialDesignObj.pieces[i].subsystem])
                updateMaterialDesign(getArrayElementById(designArr_final, updateMaterialDesignObj.pieces[i].subsystem));
            } else {
                updateMaterialDesignObj.pieces[i].array[0].mesh.material=getMaterial(API[materialOptionsObj.materialOptions[0].name]).material;
            }
        }
        return; 
    }
    
    

    function debug() {
        console.debug("debug: " + settings.debug);
        debugger;
    }
    function axes(arg) {
        if (console_flag) console.log("axes: " + settings.axes);
        if (console_flag) console.log("axes arg: " + arg);
        axesHelper.visible = settings.axes;
        lightHelperGroup.visible = settings.axes;
        render();
    }
    function setEnvironmentImage() {
        console.debug("set EnvironmentImage: " + API.Environment);
        if (API.Environment == "background color") {
            if (settings.background) {
                scene.background = materialArr[2].material.color;
            } else {
                scene.background = null;
            }
        } else {
            var envPath = "textures/cube/" + API.Environment + "/";
            // Cube
            var textureCube;
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            cubeTextureLoader.setPath(envPath);
            const ldrUrls = [ 'i_0.jpg', 'i_1.jpg', 'i_2.jpg', 'i_3.jpg', 'i_4.jpg', 'i_5.jpg'];
            textureCube = cubeTextureLoader.load( ldrUrls );
            textureCube.encoding = THREE.sRGBEncoding;
            textureEnv = textureCube;
            setEnv();
            setBackground();
        }
    }
    function setFov() {
        console.debug("set Fov: " + settings.fov);
        camera.fov = settings.fov;
        camera.updateProjectionMatrix()
        render();
    }
    function ground(arg) {
        if (console_flag) console.log("ground: " + settings.ground);
        if (console_flag) console.log("ground arg: " + arg);
        // ground
        groundMesh.visible = settings.ground;
        //background
        /*
        if (settings.ground) {
            scene.background = materialArr[2].material.color;
        } else {
            scene.background = null;
        }
        */
        //render();
    }
    function fog() {
        if (console_flag) console.log("fog: " + settings.fog);
        if (settings.fog) {
            //scene.fog = new THREE.Fog( materialArr[2].material.color, 10, 50 );
            scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );
            scene.fog.color = materialArr[2].material.color;  // color background material
        } else {
            scene.fog = null
        }
        render();
    }
    function setBlurriness() {
        console.debug("setBlurriness: " + settings.blurriness);
        scene.backgroundBlurriness = settings.blurriness;
        render();
    }
    function setUV() {
        console.debug("setUV: " + settings.UV);
        flagSetMaterialAll = settings.UV;
        setUVSubsystem(designObj, settings.UV);
        render();
    }
    function setLight() {
        console.debug("setLight: " + settings.pointLightFactor + " " + settings.directionalLightFactor);
        updateMeasures();
        render();
    }
    function setEnv() {
        console.debug("set environment: " + settings.env);
        if (settings.env) {
            scene.environment = textureEnv;  // inmediate change for GLTF
        } else {
            scene.environment = null;
        }
        environmentFlag = settings.env;
    }
    function setExposure() {
        console.debug("set Exposure: " + settings.exposure);
        renderer.toneMappingExposure = settings.exposure;
        render();
    }
    function setHemiLight() {
        console.debug("set hemiLight: " + settings.hemiLight);
        hemiLightObject.visible = settings.hemiLight;
        render();
    }
    function setBackground() {
        console.debug("set Background: " + settings.background);
        if (settings.background) {
            if (API.Environment == "background color") {
                scene.background = materialArr[2].material.color;
            } else {
                scene.background = textureEnv;
            }
        } else {
            scene.background = null;
        }
        render();
    }
    function setShadow() {
        shadowFlag = settings.shadow;
    }
    function setNoTexture   () {
        noTextureFlag = settings.noTexture;
    }
    function setAutosave() {
        autosaveFlag = settings.autosave;
    }
    function setTransparentControl() {
        transparentControlFlag = settings.transparentControl;
        if (transparentControlFlag) {
            document.querySelector("div.lil-gui.root").style.backgroundColor     ="rgba(55, 55, 55, 0.0)";
            document.querySelector("div.lil-gui.root").style['--backgroundColor']="rgba(55, 55, 55, 0.0)";
        } else {
            document.querySelector("div.lil-gui.root").style.backgroundColor     ="rgba(55, 55, 55, 1.0)";
            document.querySelector("div.lil-gui.root").style['--backgroundColor']="rgba(55, 55, 55, 1.0)";
        }
    }
    function initGui() {
        if (gui != null) gui.destroy();  // if previous GUI exists
        gui = new GUI();
        if (user_rol >= 2) {
            API["goTop"] = goTop;
            gui.add( API, "goTop").name( 'Top' );
            API["gotoMaterials"] = gotoMaterials;
            gui.add( API, "gotoMaterials").name( 'Materials' );
            API["gotoObject"] = gotoObject;
            gui.add( API, "gotoObject").name( 'Object' );
            API["gotoFile"] = gotoFile;
            gui.add( API, "gotoFile").name( 'File' );
        }
        
        parameter_index = 0;
        //getEvalParameters(designObj.parameters)
        //addParametersToFolder(gui);
        
        /*
        Folders:
        > Controls
        Top Materials Object File
          > Main
            > Parameters
            > Material properties
            > texture properties
            > settings
        */
        POM = {}; // Parameters Object Model  // *** changed to {} 26-10-2022
        var mainFolder;
        if (user_rol > 1) {
            mainFolder = gui.addFolder( 'Main' );
        }
        createParametersObjectModel(POM, 0);
        reloadGuiParameters();
//        guiParametersFolder = gui.addFolder( 'Parameters' );
//        createGuiFromPOM(POM, guiParametersFolder, 0);
        gui.onFinishChange( e => {
            if (console_flag) console.log( 'gui.onFinishChange', e );
            reloadGuiParameters();
            updateMeasures();
        } );
        
        materialGui = new THREE.MeshPhysicalMaterial( { color: 0xFF8000 } );
        materialGui.diffuseMap = true;
        materialGui.normalFactor = 3;
        var materialFolder = guiMeshPhysicalMaterial(gui, materialGui);
        if (user_rol >= 2) {
            API["SaveMaterial"] = saveMaterial;
            materialFolder.add( API, "SaveMaterial").name( 'Save material' );
        }

        if (user_rol >= 2) {
            const textureFolder = gui.addFolder( 'texture properties' );
            //textureFolder.close();

            textureFolder.add( API, 'offsetX', 0.0, 1.0 ).name( 'offset.x' ).onChange( updateUvTransform );
            textureFolder.add( API, 'offsetY', 0.0, 1.0 ).name( 'offset.y' ).onChange( updateUvTransform );
            textureFolder.add( API, 'repeatX', 0.1, 12.0 ).name( 'repeat.x' ).onChange( updateUvTransform );
            textureFolder.add( API, 'repeatY', 0.1, 12.0 ).name( 'repeat.y' ).onChange( updateUvTransform );
            textureFolder.add( API, 'rotation', - 2.0, 2.0 ).name( 'rotation' ).onChange( updateUvTransform );
            textureFolder.add( API, 'centerX', 0.0, 1.0 ).name( 'center.x' ).onChange( updateUvTransform );
            textureFolder.add( API, 'centerY', 0.0, 1.0 ).name( 'center.y' ).onChange( updateUvTransform );
        }

        if (user_rol >= 3) {
            const settingsFolder = gui.addFolder( 'settings' );
            settingsFolder.open();

            API["Render"] = updateMeasures;
            settingsFolder.add( API, "Render").name( 'Render' )
            settingsFolder.add(API, 'renders').name( 'Renders:' );

            
            if (materialOptionsObj.materialOptions != null) {
                for (var i =0; i< materialOptionsObj.materialOptions.length; i++) {
                    var materialOption = materialOptionsObj.materialOptions[i];
                    if (console_flag) console.log("materialOptions: " + materialOption.name);
                    var materialOptionsArr = [];
                    for (var j =0; j< materialOption.materials.length; j++) {
                        if (console_flag) console.log("  material: " + materialOption.materials[j].material);
                        materialOptionsArr.push(materialOption.materials[j].material);
                    }
                    materialOption.materialOptionsArr = materialOptionsArr;
                    API[materialOption.name] = materialOption.materials[0].material;
                    settingsFolder.add( API, materialOption.name, materialOptionsArr ).onChange( updateMaterial);
                }
            }
            
            var environmentAPI = [];
            environmentAPI.push("background color");
            environmentAPI.push("Park2");
            environmentAPI.push("pisa_Y");
            environmentAPI.push("DallasW");
            environmentAPI.push("grid");
            API["Environment"] = environmentAPI[0];  // .name when it's an object
            settingsFolder.add( API, "Environment", environmentAPI).onChange( setEnvironmentImage);

            settingsFolder.add( settings, 'debug' ).onChange( debug );
            settingsFolder.add( settings, 'axes' ).onChange( axes );
            settingsFolder.add( settings, 'fov', 8, 180 ).onChange( setFov );
            settingsFolder.add( settings, 'ground' ).onChange( ground );
            settingsFolder.add( settings, 'fog' ).onChange( fog );
            settingsFolder.add( settings, 'background' ).onChange( setBackground );
            settingsFolder.add( settings, 'blurriness', 0, 1 ).onChange( setBlurriness );
            settingsFolder.add( settings, 'UV' ).onChange( setUV );
            settingsFolder.add( settings, 'env' ).onChange( setEnv );
            settingsFolder.add( settings, 'pointLightFactor', 0, 5 ).onChange( setLight );
            settingsFolder.add( settings, 'directionalLightFactor', 0, 5 ).onChange( setLight );
            settingsFolder.add( settings, 'hemiLightFactor', 0, 5 ).onChange( setLight );
            settingsFolder.add( settings, 'exposure', 0, 3 ).onChange( setExposure );
            settingsFolder.add( settings, 'hemiLight' ).onChange( setHemiLight );
            settingsFolder.add( settings, 'shadow' ).onChange( setShadow );
            settingsFolder.add( settings, 'noTexture' ).onChange( setNoTexture );
            settingsFolder.add( settings, 'autosave' ).onChange( setAutosave );
            settingsFolder.add( settings, 'transparentControl' ).onChange( setTransparentControl );
            API["Full screen"] = fullScreen;
            settingsFolder.add( API, "Full screen").name( 'Full screen' )

            API["reload GUI"] = reloadGuiPieces;
            gui.add( API, "reload GUI").name( 'Load pieces GUI' )
            API["reload parameters"] = reloadGuiParameters;
            gui.add( API, "reload parameters").name( 'reload parameters' )
        }
    }
    
    function fullScreen() {
        bottomSpace = 0;
        document.querySelector("div.lil-gui.root").remove();
    }
    function goTop() {
        document.getElementById("renderDiv").scrollIntoView()

    }
    function gotoMaterials() {
        //document.getElementById("modelDiv").scrollIntoView()
        scrollOffset("modelDiv", -38.5);

    }
    function gotoFile() {
        document.getElementById("fileDiv").scrollIntoView()

    }
    function reloadGuiPieces() {
        if (guiPieces != null) guiPieces.destroy();
        var piecesFolder = gui.addFolder( 'Pieces' );
        piecesFolder.open();
        addGuiPiece(API, designObj, piecesFolder,"");
        guiPieces = piecesFolder;
    }
    function reloadGuiParameters() {
        var parametersFolder;
        if (guiParametersFolder != null) guiParametersFolder.destroy();
        if (user_rol == 1) {
            gui = new GUI();
            parametersFolder = gui;
        } else {
            var mainFolder = getGuiFolderByName(gui.folders, "Main");
            parametersFolder = mainFolder.addFolder( 'Parameters' );
        }
        createGuiFromPOM(POM, parametersFolder, 0);
        parametersFolder.open();
        guiParametersFolder = parametersFolder;
    }
    
    function addGuiPiece(API, guiPiece, folder, level) {
        for (var i =0; i< guiPiece.pieces.length; i++) {
            //console.log("Piece: " + guiPiece.pieces[i].name + " lx:" + eval(guiPiece.pieces[i].lx).toFixed(2) + " ly:" + eval(guiPiece.pieces[i].ly).toFixed(2) + " lx:" + eval(guiPiece.pieces[i].lz).toFixed(2));
            //gui
            for (var array_j = 0; array_j < guiPiece.pieces[i].array.length ; array_j++) {
                var array_level = level + "_" + array_j; 
                var name = guiPiece.pieces[i].name + array_level;
                API[name] = true;
                API[name + "array_index"] = guiPiece.pieces[i].array[array_j];
                folder.add( API, name).onChange( visibility);
                if ('subsystem' in guiPiece.pieces[i]) {
                    var subFolder = folder.addFolder( name );
                    subFolder.close();
                    addGuiPiece(API, guiPiece.pieces[i].array[array_j].subsystemDesign, subFolder, array_level)
                }
            }
        }

    }
  //]]></script>

<script>

    var parameterTypes = ["m", "u", "cm", "options", "materials", "internal", "formula", "group", "ungroup"];
    var parameterProperties = ["name", "type", "array_size", "options", "hidden", "min","max", "step", "default"];
    var pieceTypes = ["Box", "Cylinder", "Sphere", "Triangle", "Extrude", "Revolution", "Gltf"]; //, "Module"];  Module is replaced by each type of object
    var pieceProperties1 = ["name", "type", "operation"];
    var pieceProperties3 = ["array_size", "sx", "sy", "sz", "rx", "ry", "rz", "x", "y", "z"];
    var typeProperties = {};
    typeProperties["Box"] = ["lx","ly", "lz", "material_1", "material_2", "material_3", "material_4", "material_5", "material_6" ];
    typeProperties["Cylinder"] = ["rt","rb", "lz", "material_1", "material_2", "material_3"];
    typeProperties["Sphere"] = ["r", "material_1"];
    typeProperties["Triangle"] = ["b","h", "d", "lz", "material_1", "material_2"];
    /*
    <-->d
       /\      |h
      /  \     |
     /    \    |
    /______\   |
    <------>b

    */
    typeProperties["Extrude"] = ["shape_array", "lz", "material_1", "material_2"];
    typeProperties["Revolution"] = ["shape_array", "lz", "material_1"];
    typeProperties["Gltf"] = ["url"];
    typeProperties["Module"] = ["subsystem", "parameters"];
    var pieceProperties = {};
    piecePropertiesTable          = pieceProperties1.concat(["parameters"]); //, pieceProperties3);
    pieceProperties["Box"]        = pieceProperties1.concat(typeProperties["Box"],      pieceProperties3);
    pieceProperties["Cylinder"]   = pieceProperties1.concat(typeProperties["Cylinder"], pieceProperties3);
    pieceProperties["Sphere"]     = pieceProperties1.concat(typeProperties["Sphere"],    pieceProperties3);
    pieceProperties["Triangle"]   = pieceProperties1.concat(typeProperties["Triangle"], pieceProperties3);
    pieceProperties["Extrude"]    = pieceProperties1.concat(typeProperties["Extrude"],  pieceProperties3);
    pieceProperties["Revolution"] = pieceProperties1.concat(typeProperties["Revolution"],  pieceProperties3);
    pieceProperties["Gltf"]       = pieceProperties1.concat(typeProperties["Gltf"],     pieceProperties3);
    pieceProperties["Module"]     = pieceProperties1.concat(typeProperties["Module"],   pieceProperties3);

    parameterDefaults = {"Box":{"lx":1,"ly":0.4,"lz":0.10}
                        ,"Cylinder":{"rt":0.5,"rb":0.5,"lz":1}
                        ,"Sphere":{"r":0.51}
                       }

//  Lights
    var lightTypes = ["Point", "Directional"]; //, "Spot"];
    typeProperties["Point"] = ["intensity","distance", "decay"];
    typeProperties["Directional"] = ["intensity"];
    //typeProperties["Spot"] = ["intensity","distance", "angle", "penumbra", "decay"];
    pieceProperties["Point"]      = pieceProperties1.concat(typeProperties["Point"], pieceProperties3);
    pieceProperties["Directional"]= pieceProperties1.concat(typeProperties["Directional"], pieceProperties3);
    //pieceProperties["Spot"]       = pieceProperties1.concat(typeProperties["Spot"], pieceProperties3);

    //materialProperties = ["name","type","texture","texture1","texture2","texture3","texture4","texture5","texture6"];
    materialProperties = ["name","size_x","size_y","angle","texture", "texture_image", "roughnessMap", "roughness_image", "normalMap", "normal_image",  
        "color_r", "color_g", "color_b", "color", "emissive_r", "emissive_g", "emissive_b", "emissive", "roughness", "metalness", "reflectivity", "clearcoat", "clearcoatRoughness", "transparent", "opacity", "diffuseMap", "normalFactor", "envMapIntensity", "ior", "wireframe", "side"]
    materialPropertiesTable = ["name","texture_image", "normal_image", "roughness_image", 
        "color", "emissive", "opacity", "diffuseMap", "normalFactor"];
    objectPropertiesTable = ["name","description", "publish", "image"];

    var subsystemParameterProperties = ["name", "default"];

    function evalContext(expr){
        return eval(expr);
    }

    function printTime(text) {
        if (console_flag_time) {
            //var dateT = new Date();
            //console.log("time: " /* + dateT.getMinutes() + ":" */ + dateT.getSeconds() + ":" + dateT.getMilliseconds()  + " at " + text);
            var diff = (new Date).getTime() - start_time;
            console.log("time: "  + diff / 1000 + " at " + text);
        }
    }

    function setTextAreaSize() {
        if (document.getElementById("jsonObj").style.width == "") {
            document.getElementById("jsonObj").style.width = "660px";
            document.getElementById("jsonObj").style.height = "230px";
        }
    }
    function exportCollection() {
        collectionExport = {};
        //collectionExport.materials = materialArr;
        //collectionExport.materialOptions = materialOptionsObj;
        collectionExport.materialArr = [];
        for (var i_mat = 0; i_mat < materialArr.length; i_mat++) {
            collectionExport.materialArr[i_mat] = {};
            collectionExport.materialArr[i_mat].id = materialArr[i_mat].id;
                    for (var j =0; j< materialProperties.length; j++) {
                        collectionExport.materialArr[i_mat][materialProperties[j]] = materialArr[i_mat][materialProperties[j]];
                    }
        }
        
        //collectionExport.designArr = {};  // to remove when designArr_final -> designArr
        collectionExport.designArr = [];
        for (var iObject =0; iObject< designArr_final.length; iObject++) {
            exportDesignObject = {};
        //    collectionExport.designArr[designArr_final[iObject].name] = exportDesignObject;
            collectionExport.designArr.push(exportDesignObject);
                for (var i =0; i< objectPropertiesTable.length; i++) {
                    //exportDesignObject.id = designArr_final[iObject].id;
                    //exportDesignObject.name = designArr_final[iObject].name;
                    exportDesignObject.id = designArr_final[iObject].id;
                    exportDesignObject[objectPropertiesTable[i]] = designArr_final[iObject][objectPropertiesTable[i]];
                }
                // Parameters
                exportDesignObject.parameters = [];
                for (var i =0; i< designArr_final[iObject]['parameters'].length; i++) {
                    exportDesignObject.parameters[i] = {};
                    for (var j =0; j< parameterProperties.length; j++) {
                        exportDesignObject.parameters[i][parameterProperties[j]] = designArr_final[iObject]['parameters'][i][parameterProperties[j]];
                        
                    }
                }
                // Pieces
                exportDesignObject.pieces = [];
                for (var i =0; i< designArr_final[iObject]['pieces'].length; i++) {
                    exportDesignObject.pieces[i] = {};
                    type = designArr_final[iObject]['pieces'][i].type;
                    if (type == null || type == "") type = "Box";
                    for (var j =0; j< pieceProperties[type].length; j++) {
                        exportDesignObject.pieces[i][pieceProperties[type][j]] = designArr_final[iObject]['pieces'][i][pieceProperties[type][j]];
                        if (pieceProperties[type][j].startsWith("material_")) {
                            exportDesignObject.pieces[i][pieceProperties[type][j] + "_Perpendicular"] = designArr_final[iObject]['pieces'][i][pieceProperties[type][j] + "_Perpendicular"];
                        }
                    }
                }

        }
        document.getElementById('jsonObj').value = JSON.stringify(collectionExport)
    }


/*
        var H1El = document.createElement("H1");
        H1El.innerHTML  = "Materials";
        divEl.appendChild( H1El);

        H1El.innerHTML  = "Objects";
        divEl.appendChild( H1El);

*/
    
    function printMaterialTable() {
        if (console_flag) console.log("Material: " + "materialTable");
        var modelDiv = document.getElementById('modelDiv')

        /*
        var divEl = document.getElementById("materialTable");
        if (divEl == null) {  // create node or delete content node
            divEl = document.createElement("DIV");
            divEl.setAttribute("id", "materialTable");
            modelDiv.appendChild( divEl);
        } else {
            divEl.textContent = ''
        }
        var H1El = document.createElement("H1");
        H1El.innerHTML  = "Materials";
        H1El.setAttribute("class", "materials");
        divEl.appendChild( H1El);
        */
        var divEl = createPanel("materials", "Materials", "Materials")


//        var tableMat = createTable("materialTable", materialArr, "obj_material", materialProperties);
        var tableMat = createTable("Materials", "Materials", materialArr, "obj_material", materialPropertiesTable);
        divEl.appendChild( tableMat);
    }

    function printObjectsTable() {
        if (console_flag) console.log("Objects: " + "ObjectsTable");
        var modelDiv = document.getElementById('modelDiv')

        var divEl = createPanel("objects", "Objects", "Objects")
        var tableObj = createTable("Objects", "Objects", designArr_final, "obj_object", objectPropertiesTable);
        divEl.appendChild( tableObj);
    }


    function createPanel(typePanel, elementName, elementId) {
        // it is a LI element to allow hide the element
        var liEl = document.getElementById(elementId);
        
        if (liEl == null) {
            liEl = document.createElement("LI");
            liEl.setAttribute("class", "prepanel");
            var spanEl = document.createElement("span");
            var liText = document.createTextNode(typePanel + ": " + elementName);
            spanEl.appendChild(liText);
            liEl.appendChild(spanEl);
            liEl.setAttribute("id", elementId);
            modelDiv.appendChild( liEl);

            if (typePanel == "object") {
                // View object
                var aEl = document.createElement("A");
                aEl.setAttribute("onClick", "viewObject('" + elementId + "')");
                aEl.setAttribute("class", "objectLink loadLink");
                var linkText = document.createTextNode("View object");
                aEl.appendChild(linkText);
                aEl.href = "#renderDiv";  // "javascript:void(0);";
                liEl.appendChild(aEl);        
            }
        }

        var divEl = document.getElementById("panel_" + elementId);
        if (divEl == null) {  // create node or delete content node
            divEl = document.createElement("DIV");
            divEl.setAttribute("class", "panel");
            divEl.setAttribute("id", "panel_" + elementId);
            modelDiv.appendChild( divEl);
        } else {
            divEl.textContent = ''
        }

        var H1El = document.createElement("H1");
        if (typePanel == "object") {
            H1El.setAttribute("onClick", "editObjectName('" + elementName + "')");
        }
        H1El.innerHTML  = elementName;
        divEl.appendChild( H1El);
        return divEl;
    }

    function printModelTable(obj) {
        var modelName = obj.name;
        var modelDiv = document.getElementById('modelDiv')

        var divEl = createPanel("object", modelName, obj.id)
        
        // View object
        var aEl = document.createElement("A");
        aEl.setAttribute("onClick", "viewObject('" + obj.id + "')");
        aEl.setAttribute("class", "objectLink loadLink");
        var linkText = document.createTextNode("View object");
        aEl.appendChild(linkText);
        aEl.href = "#renderDiv";  // "javascript:void(0);";
        divEl.appendChild(aEl);        

        // Go top
        var aEl = document.createElement("A");
        aEl.setAttribute("class", "objectLink goTop");
        var linkText = document.createTextNode("Go top");
        aEl.appendChild(linkText);
        aEl.href = "#renderDiv";
        divEl.appendChild(aEl);        

        // Duplicate object
        var dEl = document.createElement("A");
        dEl.setAttribute("onClick", "duplicateObject('" + modelName + "')");
        dEl.setAttribute("class", "objectLink duplicateLink");
        var linkText = document.createTextNode("Duplicate object");
        dEl.appendChild(linkText);
        dEl.href = "javascript:void(0);";
        divEl.appendChild(dEl);        

        // Parameters
        var H2parametersEl = document.createElement("H2");
        H2parametersEl.innerHTML  = "Parameters";
        H2parametersEl.setAttribute("class", "parameters");
        divEl.appendChild( H2parametersEl);
        var tableEl = createTable(modelName, obj.id, obj.parameters, "obj_parameter", parameterProperties);
        divEl.appendChild( tableEl);

        // Pieces
        var H2piecesEl = document.createElement("H2");
        H2piecesEl.innerHTML  = "Pieces";
        H2piecesEl.setAttribute("class", "pieces");
        divEl.appendChild( H2piecesEl);
        type = obj.type;
        if (type == null || type == "") type = "Box";
        var tableEl = createTable(modelName, obj.id, obj.pieces, "obj_piece", piecePropertiesTable);
        divEl.appendChild( tableEl);
        
    }

    function editObjectName(modelName) {
        if (console_flag) console.log("previous name: " + modelName);
        
        let newName = prompt("Enter the new name for " + modelName, modelName);
        if (newName != null && newName != modelName) {
            if (console_flag) console.log("new name: " + newName);
            var objectToChangeName = getArrayElementByName(designArr_final, modelName);
            objectToChangeName.name = newName;
            objectName = newName;
            setDesignObject();
            init();
        }
    }

    function viewObject(model_id) {
        objectPOM = null; // delete possible design, can be from another object
        designObj  = getArrayElementById(designArr_final, model_id);
        objectName = designObj.name;
        objectId   = designObj.id;
        exportCollection();
        loadJSON();
//        designArr = JSON.parse(document.getElementById('jsonObj').value).designArr;
//        setDesignObject();
        init();
    }

    function resetEditor() {
        designObj = {"name":"void","parameters":[],"pieces":[]};
        init();
    }

    function duplicateObject(modelName) {
        exportCollection();
        designArr = JSON.parse(document.getElementById('jsonObj').value).designArr_final;
        designObj2 = JSON.parse(JSON.stringify(getArrayElementByName(designArr_final, modelName)));
        newName = modelName + "_2";
        designObj2.name = newName;
        designObj2.id = randomString(10);
        designArr_final.push(designObj2);
        viewObject(designObj2.id);
    }

    function newObject() {
        designObj2 = {};
        newName = "new object";
        designObj2.id = randomString(10);
        designObj2.name = newName;
        designObj2.parameters = [];
        designObj2.pieces = [];
        designArr_final.push(designObj2);
        viewObject(designObj2.id);
    }
    
    function randomString(string_length) {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
        var resultString = '';
        for (var i=0; i<string_length; i++) {
        var rnum = Math.floor(Math.random() * chars.length);
        resultString += chars.substring(rnum,rnum+1);
        }
        return resultString;
    }

    function createTable(modelName, model_id, objArray, form_entity, properties, i_element) {
        // i_element only used in obj_subsystem_parameter
        var tableEl = document.createElement("TABLE");
        tableEl.setAttribute("class", form_entity);
        tableEl.setAttribute("id", form_entity + "_" + model_id);

        tableEl.setAttribute("border", "1");
        var trEl = document.createElement("TR");
        //first row (header)
        addNew(trEl, modelName, model_id, form_entity, i_element);
        for (var j =0; j< properties.length; j++) {
            addHeader(trEl, properties[j]);
        }
        tableEl.appendChild(trEl);

        if (objArray != null) {
            for (var i =0; i< objArray.length; i++) {
                //setDefaultValues(objArray[i]);
                //console.log("Piece: " + obj.pieces[i].name + " lx:" + eval(obj.pieces[i].lx).toFixed(2));
                var trEl = document.createElement("TR");

                addEdit(trEl, i, modelName, model_id, form_entity, i_element);
                for (var j =0; j< properties.length; j++) {
                    addCell(trEl, objArray[i], properties[j], i, modelName, form_entity);
                }
                tableEl.appendChild(trEl);
            }
        }
        return tableEl;
    }

    function addHeader(trEl, property) {
        var tdEl = document.createElement("TH");
        var textNode = document.createTextNode(property);
        tdEl.appendChild(textNode);
        trEl.appendChild(tdEl);
    }
    function addCell(trEl, obj, property, i_piece, modelName, form_entity) {  // obj is piece or a parameter
        var tdEl = document.createElement("TD");
        var textContent = "";
        if (form_entity == "obj_piece" && property == "type") {   // this if can be deleted when the data are right
            if (obj[property] == null || obj[property] == "") {
                obj[property] = "Box";
            }
        }
        if (form_entity == "obj_piece" && property == "parameters") {
            val = "";
            for (var k =0; k< typeProperties[obj.type].length; k++) {
                if (k > 0) val += " - ";
                typeProperty = typeProperties[obj.type][k];
                if (typeProperty == "parameters") {
                    /* replaced by edition of parameter in piece form
                    tdEl.innerHTML = linkTableSusbsystemParameter(i_piece, modelName, "obj_subsystem_parameter");
                    */
                } else {
                    val += obj[typeProperty];
                }
            }
            textContent = val;
            textNode = document.createTextNode(textContent);
            tdEl.appendChild(textNode);
        } else if (form_entity == "obj_material" && property == "texture_image") {
            if (obj.texture != null && obj.texture != "") {
                tdEl.setAttribute("style", "background-image: url('" + obj.texture + "'); background-size: 100%;");
                tdEl.setAttribute("onclick", "window.open('" + obj.texture + "');");
            }
        } else if (form_entity == "obj_material" && property == "normal_image") {
            if (obj.normalMap != null && obj.normalMap != "") {
                tdEl.setAttribute("style", "background-image: url('" + obj.normalMap + "'); background-size: 100%;");
                tdEl.setAttribute("onclick", "window.open('" + obj.normalMap + "');");
            }
        } else if (form_entity == "obj_material" && property == "roughness_image") {
            if (obj.roughnessMap != null && obj.roughnessMap != "") {
                tdEl.setAttribute("style", "background-image: url('" + obj.roughnessMap + "'); background-size: 100%;");
                tdEl.setAttribute("onclick", "window.open('" + obj.roughnessMap + "');");
            }
        } else if (form_entity == "obj_material" && property == "color") {
            if (obj.color_r != null && obj.color_r != "") {
                tdEl.setAttribute("style", "background-color: rgb(" + (obj.color_r * 255) + ", " +  (obj.color_g * 255) + ", " +  (obj.color_b * 255) + ")");
            }
        } else if (form_entity == "obj_material" && property == "emissive") {
            if (obj.emissive_r != null && obj.emissive_r != "") {
                tdEl.setAttribute("style", "background-color: rgb(" + (obj.emissive_r * 255) + ", " +  (obj.emissive_g * 255) + ", " +  (obj.emissive_b * 255) + ")");
            }
        } else if (obj[property] != null && obj[property] != "") {
            textContent = obj[property];
            textNode = document.createTextNode(textContent);
            tdEl.appendChild(textNode);
        }

        
        trEl.appendChild(tdEl);
    }

    function createNewSelect(trEl, modelName, form_entity, i_piece) {
    }
    
    function getSelectedType(selectElement) {
        var parentGroup = document.querySelector('#' + selectElement.id + ' option:checked').parentElement  // return the option group of the selected element
        var type;
        if (parentGroup.nodeName == "OPTGROUP") {
            type = parentGroup.label;
        } else {
            type = selectElement.value;
        }
        return type;
    }
    function addNew(trEl, modelName, model_id, form_entity, i_piece) {
        var tdEl = document.createElement("TD");
        tdEl.setAttribute("class", "new");
        if (form_entity == "obj_piece") {  // put a SELECT for selection of type of piece
            var text1Node = document.createTextNode("New:");
            tdEl.appendChild(text1Node);
            var selectPieceType = document.createElement("SELECT");
            selectPieceType.setAttribute("id", "newSelect_" + model_id);
            selectPieceType.setAttribute("class", "newSelect");
            selectPieceType.setAttribute("onchange", "createForm(" + -1 + ", \"" + modelName + "\", \"" + model_id + "\",\"N\", \"" + form_entity + "\", " + i_piece + ", getSelectedType(this), this.options[this.selectedIndex].value)");  // this.value, this.options[this.selectedIndex].value, this.options[this.selectedIndex].text
            selectPieceType.setAttribute("onfocus", "this.selectedIndex = -1;");
            var option = document.createElement("option");
            option.text = "Select type";
            option.value = "0";
            option.setAttribute("style","display:none;");
            selectPieceType.add(option);
            for (var j =0; j< pieceTypes.length; j++) {
                option = document.createElement("option");
                option.text  = pieceTypes[j];
                option.value = pieceTypes[j];
                selectPieceType.add(option);
            }
            var optgroup = document.createElement("optgroup");
            optgroup.label = "Module";
            selectPieceType.add(optgroup);

//           for (var prop in designArr) {
//              if (Object.prototype.hasOwnProperty.call(designArr, prop)) {
            for (var iObject =0; iObject< designArr_final.length; iObject++) {
                    option = document.createElement("option");
                    option.text = designArr_final[iObject].name;
                    option.value = designArr_final[iObject].id;  //"Module";
                    optgroup.appendChild(option);
            }
            var lightsGroup = document.createElement("optgroup");
            lightsGroup.label = "Lights";
            selectPieceType.add(lightsGroup);
            for (var k =0; k< lightTypes.length; k++) {
                    option = document.createElement("option");
                    option.text  = lightTypes[k];
                    option.value = lightTypes[k];
                    lightsGroup.appendChild(option);
            }
            tdEl.appendChild(selectPieceType);
        } else if (form_entity == "obj_parameter") {  // put a SELECT for selection of type of parameter
            var text1Node = document.createTextNode("New:");
            tdEl.appendChild(text1Node);
            var selectParameterType = document.createElement("SELECT");
            selectParameterType.setAttribute("class", "newSelect");
            selectParameterType.setAttribute("onchange", "createForm(" + -1 + ", \"" + modelName + "\", \"" + model_id + "\",\"N\", \"" + form_entity + "\", " + i_piece + ", this.value, this.options[this.selectedIndex].text)");
            selectParameterType.setAttribute("onfocus", "this.selectedIndex = -1;");
            var option = document.createElement("option");
            option.text = "Select type";
            option.value = "0";
            option.setAttribute("style","display:none;");
            selectParameterType.add(option);
            for (var j =0; j< parameterTypes.length; j++) {
                option = document.createElement("option");
                option.text  = parameterTypes[j];
                option.value = parameterTypes[j];
                selectParameterType.add(option);
            }

            tdEl.appendChild(selectParameterType);
        } else{
            tdEl.innerHTML = 
              "<a onclick='createForm(" + -1 + ", \"" + modelName + "\", \"" + model_id + "\",\"N\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'>New</a>";
        }
        trEl.appendChild(tdEl);
    }

    var setOrderButtons = true;
    function addEdit(trEl, i_row, modelNameString, model_id, form_entity, i_piece) {
        var tdEl = document.createElement("TD");
        tdEl.setAttribute("class", "edit");
        tdEl.innerHTML = 
          "&nbsp;<a onclick='createForm(" + i_row + ", \"" + modelNameString + "\", \"" + model_id + "\",\"E\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'><i class='fa fa-pencil-square-o'></i></a>" + "&nbsp;&nbsp;" + 
          "<a onclick='createForm(" + i_row + ", \"" + modelNameString + "\", \"" + model_id + "\",\"D\", \"" + form_entity + "\", " + i_piece +")' href='javascript:void(0);'><i class='fa fa-files-o'></i></a>";

        trEl.appendChild(tdEl);
        if (setOrderButtons) {
            elem_i = document.createElement("i");
            elem_i.classList.add("accIcon");
            elem_i.classList.add("fa");
            elem_i.classList.add("fa-caret-up");
            tdEl.appendChild(elem_i)
            elem_i.setAttribute("onclick", "moveElement(true, " + i_row + ", '" + modelNameString + "', '" 
              + form_entity + "', " + i_piece + ")");
            elem_i = document.createElement("i");
            elem_i.classList.add("accIcon");
            elem_i.classList.add("fa");
            elem_i.classList.add("fa-caret-down");
            elem_i.setAttribute("onclick", "moveElement(false, " + i_row + ", '" + modelNameString + "', '" 
              + form_entity + "', " + i_piece + ")");
            tdEl.appendChild(elem_i)
        }

    }

    function moveElement(up, i_row, modelNameString, form_entity, i_piece) {
        if (console_flag) console.log("element: " + i_row);
        var array;
        if (form_entity == "obj_piece") {
            array = getArrayElementByName(designArr_final, modelNameString).pieces;
        } else if (form_entity == "obj_parameter") {
            array = getArrayElementByName(designArr_final, modelNameString).parameters;
        } else if (form_entity == "obj_material") {
            array = materialArr;
        } else if (form_entity == "obj_object") {
            array = designArr_final;
        }
        if (up) {
            if (i_row > 0) {
                var tmp = array[i_row - 1];
                array[i_row - 1] = array[i_row];
                array[i_row] = tmp;
            }
        } else {  // down
            if (i_row < array.length -1) {
                var tmp = array[i_row + 1];
                array[i_row + 1] = array[i_row];
                array[i_row] = tmp;
            }
        }
        
        if (form_entity == "obj_material") {
            printMaterialTable();
        } else if (form_entity == "obj_object") {
            printObjectsTable();
        } else if (form_entity == "obj_piece" || form_entity == "obj_parameter") {
            //printModelTable(modelNameString, getArrayElementByName(designArr_final, modelNameString));
            printModelTable(getArrayElementByName(designArr_final, modelNameString));
        }

    }
    
    function addDivForEdit(modelName) {
        var formEl = document.getElementById("editObject");
        if (formEl != null) {
            formEl.remove();
        }

        formEl = document.createElement("DIV");  //Changed from FORM to DIV to prevent send
        formEl.setAttribute("id", "editObject");
//        formEl.setAttribute("method", "GET");
//        formEl.setAttribute("action", "javascript:void(0);");
        return formEl;
    }

    function createForm(i_array, modelName, model_id, formType, form_entity, i_element, selected_type, selected_module) {
        if (console_flag) console.log("createForm " + i_element);
        
        var formObjectDesign = getArrayElementById(designArr_final, model_id);
        
        var renderDiv = document.getElementById("renderDiv");  // get renderDiv before delete formArea

        var formDivMain = addDivForEdit(model_id);
        
        formEl = document.createElement("DIV");  //Changed from FORM to DIV to prevent send
        formEl.setAttribute("id", "formArea");
        formDivMain.appendChild(formEl);

        formEl.appendChild(addHiddenField("sys_object", modelName));
        formEl.appendChild(addHiddenField("sys_formType", formType));
        formEl.appendChild(addHiddenField("sys_array", i_array));

        var objectElement;
        if (form_entity == "obj_parameter") {
            panel = document.getElementById("panel_" + model_id);
            tableNode = document.getElementById("obj_parameter" + "_" + model_id);
            panel.insertBefore(formDivMain, tableNode.nextSibling);
            
            formEl.appendChild(addHiddenField("sys_type", "sys_parameter"));
            objectElement = formObjectDesign.parameters[i_array];
            properties = parameterProperties;
        } else if (form_entity == "obj_piece") {
            document.getElementById("panel_" + model_id).appendChild(formDivMain);
            formEl.appendChild(addHiddenField("sys_type", "sys_piece"));
            objectElement = formObjectDesign.pieces[i_array];
            if (objectElement != null) type = objectElement.type;
            if (formType == "N") {
                if (console_flag) console.log("createForm type: " + selected_type);
                type = selected_type;
            }
            if (type == null || type == "") type = "Box";
            properties = pieceProperties[type];
        } else if (form_entity == "obj_subsystem_parameter") {
            document.getElementById("panel_" + model_id).appendChild(formDivMain);
            formEl.appendChild(addHiddenField("sys_type", "sys_subsystem_parameter"));
            formEl.appendChild(addHiddenField("sys_element", i_element));
            if (i_array != -1) {
                objectElement = formObjectDesign.pieces[i_element]["parameters"][i_array];
            }
            properties = subsystemParameterProperties;
        } else if (form_entity == "obj_material") {
            document.getElementById("panel_" + model_id).appendChild(formDivMain);
            formEl.appendChild(addHiddenField("sys_type", "sys_material"));
            objectElement = materialArr[i_array];
            properties = materialProperties;
        } else if (form_entity == "obj_object") {
            document.getElementById("panel_" + model_id).appendChild(formDivMain);
            formEl.appendChild(addHiddenField("sys_type", "sys_collectionObject"));
            objectElement = designArr_final[i_array];
            properties = objectPropertiesTable;
        } else {
            if (console_flag) console.log("form_entity: " + form_entity + " not defined *********");
        }

        for (var j =0; j< properties.length; j++) {
            var propertyName  = properties[j];
            var propertyValue = "";
            if (formType == "N") {
                if (form_entity == "obj_piece" && propertyName == "type") {
                    propertyValue = selected_type;
                } else if (form_entity == "obj_parameter" && propertyName == "type") {
                    propertyValue = selected_type;
                } else if (form_entity == "obj_piece" && propertyName == "subsystem") {
                    propertyValue = selected_module;
                }
            } else {
                if (objectElement[properties[j]] != null) {
                    propertyValue = objectElement[properties[j]];
                }
            }
            if (form_entity == "obj_piece" && propertyName == "shape_array") {
                if (console_flag) console.log("shape_array");
                divEl = createArrayForm(formEl, propertyValue,  "shapeForm",  "Shape points", ["X","Y","C1X","C1Y","C2X","C2Y"], "Point", ["x", "y", "c1x", "c1y","c2x","c2y"], ["", ""], ["", "", "", "", "", ""], "Add Curve" );

            } else if (form_entity == "obj_piece" && propertyName == "parameters"){
                if (formType == "N") {
                    arrayProperties = getArrayElementById(designArr_final, selected_module).parameters;
                    // create an array of properties with the default values
                    arrayPropertiesWithDefaultValues = [];
                    for (var i_property =0; i_property < arrayProperties.length; i_property++) {
                        arrayPropertiesWithDefaultValues[i_property] = {};
                        arrayPropertiesWithDefaultValues[i_property].name = arrayProperties[i_property].name;
                        if (arrayProperties[i_property].type == "cm") {
                            arrayPropertiesWithDefaultValues[i_property].default
                              = eval(arrayProperties[i_property].default) / 100;
                        } else {
                            arrayPropertiesWithDefaultValues[i_property].default 
                              = eval(arrayProperties[i_property].default);
                        }
                    }
                    arrayPropertiesValues = arrayPropertiesWithDefaultValues;
                } else {
                    var subsystem = formObjectDesign.pieces[i_array].subsystem;

                    if (subsystem.startsWith("parameter:")) {
                        arrayProperties = getParametersOfModuleOption(modelName, subsystem.substring(10));
                    } else {
                        arrayProperties = getArrayElementById(designArr_final, subsystem).parameters;
                    }
                    arrayPropertiesValues = formObjectDesign.pieces[i_array].parameters
                }
                createParametersModuleArrayForm(formEl, arrayProperties, arrayPropertiesValues); //***
            } else if (form_entity == "obj_piece" && propertyName.startsWith("material")) {
                if (console_flag) console.log("materials");
                var divEl = document.createElement("DIV");
                var span1El = document.createElement("SPAN");
                var text1Node = document.createTextNode(propertyName);
                divEl.appendChild(span1El);
                span1El.appendChild(text1Node);
                var selectEl = document.createElement("SELECT");
                for (var i_mat =0; i_mat< materialArr.length; i_mat++) {
                    var option = document.createElement("option");
                    option.text  = materialArr[i_mat].name;
                    option.value = materialArr[i_mat].id;
                    selectEl.add(option);
                }
                
                var parametersGroup = document.createElement("optgroup");
                parametersGroup.label = "Parameters";
                selectEl.add(parametersGroup);
                for (var k =0; k< formObjectDesign.parameters.length; k++) {
                    if (formObjectDesign.parameters[k].type == "options"
                     || formObjectDesign.parameters[k].type == "materials"
                     || formObjectDesign.parameters[k].type == "formula") {
                        option = document.createElement("option");
                        option.text  = formObjectDesign.parameters[k].name;
                        option.value = "parameter:" + formObjectDesign.parameters[k].name;
                        parametersGroup.appendChild(option);
                    }
                }

                selectEl.setAttribute("id", propertyName);
                selectEl.setAttribute("class", "property");
                selectEl.value = propertyValue;
                //onchange 
                selectEl.onchange =function() {elementOninput(this)};
                divEl.appendChild(selectEl);
                // add perpendicular texture
                var spanPerpendicularEl = document.createElement("INPUT");
                spanPerpendicularEl.setAttribute("id", propertyName + "_Perpendicular");
                spanPerpendicularEl.setAttribute("type", "checkbox");
                spanPerpendicularEl.setAttribute("class", "property materialPerpendicular");
                spanPerpendicularEl.setAttribute("size", "1");
                if (formType == "N") {
                    propertyPerpendicularValue = false;
                } else {
                    propertyPerpendicularValue = objectElement[properties[j] + "_Perpendicular"];
                }
                if (propertyPerpendicularValue != null && propertyPerpendicularValue == true) {
                    spanPerpendicularEl.checked = true;
                } else {
                    spanPerpendicularEl.checked = false;
                }
                //spanPerpendicularEl.value = propertyPerpendicularValue;
                spanPerpendicularEl.oninput=function() {elementOninput(this)};
                divEl.appendChild(spanPerpendicularEl);                
                // end perpendicular texture
                formEl.appendChild(divEl);
            } else if (form_entity == "obj_parameter" && propertyName == "options"){
                if (document.getElementById("type").value == "options") {
                    if (console_flag) console.log("options form");
                    divEl = createArrayForm(formEl, propertyValue,  "optionsForm",  "Options", ["name","value"], "Option", ["op_name", "op_value"], ["", ""]);
                } else if (document.getElementById("type").value == "materials") {
                    if (console_flag) console.log("materials form");
                    divEl = createArrayForm(formEl, propertyValue,  "materialsForm",  "Materials", ["name","value"], "Material", ["op_name", "op_value"], ["", ""]);
                }
            } else {
                var divEl = document.createElement("DIV");
                var span1El = document.createElement("SPAN");
                var text1Node = document.createTextNode(propertyName);
                divEl.appendChild(span1El);
                span1El.appendChild(text1Node);
                var span2El = document.createElement("INPUT");
                span2El.setAttribute("id", propertyName);
                span2El.setAttribute("class", "property");
                span2El.value = propertyValue;
                if (form_entity == "obj_piece") {
                    //oninput
                    span2El.oninput=function() {elementOninput(this)};
                }
                divEl.appendChild(span2El);
                formEl.appendChild(divEl);
            }
        }
        if (form_entity == "obj_piece") {
            var buttonSaveEl = document.createElement("BUTTON");
            buttonSaveEl.setAttribute("onClick", "updateObject()");
            var tSave = document.createTextNode("Save and continue");
            buttonSaveEl.appendChild(tSave);
            formEl.appendChild(buttonSaveEl);
        }
        var buttonSaveCloseEl = document.createElement("BUTTON");
        buttonSaveCloseEl.setAttribute("onClick", "updateObjectClose()");
        var tSaveClose = document.createTextNode("Save");
        buttonSaveCloseEl.appendChild(tSaveClose);
        formEl.appendChild(buttonSaveCloseEl);

        var buttonCancelEl = document.createElement("BUTTON");
        buttonCancelEl.setAttribute("onClick", "cancelEdit()");
        var tCancel = document.createTextNode("Cancel");
        buttonCancelEl.appendChild(tCancel);
        formEl.appendChild(buttonCancelEl);

        if (form_entity == "obj_piece") {
            // We print the 3D after the form, so if there is an error with parameters
            // at updateMeasures() the form is printed anyway and the user can modify it
            if (renderDiv != null) {
                //renderArea = document.createElement("DIV");  //Changed from FORM to DIV to prevent send
                //renderArea.setAttribute("id", "renderArea");
                renderArea = document.getElementById("renderArea");
                //formDivMain.appendChild(renderArea);
                var renderColumnDiv = document.getElementById("renderColumnDiv");
                renderColumnDiv.appendChild(renderArea);
                renderArea.appendChild(renderDiv);
                rendererWidth  = renderArea.offsetWidth - 8;
                rendererHeight = renderArea.offsetHeight- 8;
                // move the renderDiv node here2
        //        renderer.setPixelRatio( rendererWidth / rendererHeight);
                camera.aspect = rendererWidth / rendererHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( rendererWidth, rendererHeight);
                updateMeasures();
                onWindowResize();
                
            }
            
        } else {
            //moveRenderDivUp(renderDiv);
            document.getElementById("formArea").scrollIntoView();
        }
        // final size because it was initially collapsed
        var panelDiv = document.getElementById("panel_" + model_id);
        panelDiv.style.maxHeight = panelDiv.scrollHeight + "px";

        if (form_entity == "obj_piece") {
           elementOninput(); 
        }
    }
    
    function elementOninput(element) {
        if (element != null) {
            if (console_flag) console.log("elementOninput:" + element.value);
            if (lastElement != null && lastElement.classList.contains("error")) {
                if (element == lastElement) {
                    lastElement.classList.remove("error");
                }
            } else if (lastElement != null && !lastElement.classList.contains("error")) {
                lastElement = element;
            } else if (lastElement == null) {
                lastElement = element;
            }
        }
        if (autosaveFlag) {
            updateObject();
            updateMeasures();
        }
    }
    function getParametersOfModuleOption(object, parameterElementName) {
        /* to get the parameters of all the options :
        */
        var indexOfDot = parameterElementName.lastIndexOf(".");
        if (indexOfDot > 3) {
            parameterElementName = parameterElementName.substring(indexOfDot + 1)
        }
        var parameterElement = getArrayElementByName(getArrayElementByName(designArr_final, object).parameters, parameterElementName);
        var parameterOptions = parameterElement.options;
        var arrayParameterOptions = [];
        for (var i_opt =0; i_opt < parameterOptions.length; i_opt++) {
            var optionValue = parameterOptions[i_opt][1];  // element 1 is the value, the name of the object
            var optionsArray = getArrayElementById(designArr_final, optionValue.replaceAll("'","")).parameters;
            for (var j_opt =0; j_opt< optionsArray.length; j_opt++) {
                var existParameter = getArrayElementByName(arrayParameterOptions, optionsArray[j_opt].name);
                if (existParameter == null) {
                    arrayParameterOptions.push(optionsArray[j_opt]);
                }
            }
        }
        return arrayParameterOptions;
    }

    var parameter_index;
    function createParametersObjectModel(currentPOM, level) { // create POM
        if (level == 0 && false) { // first time
        //if (level == 0) { // first time
            var evalParameters = getEvalParameters(designObj.parameters, "array_i=0;");
            eval(evalParameters);
        }
        var evalText = "";
        while (parameter_index< designObj.parameters.length) {
            var designObjParameter = designObj.parameters[parameter_index];
            if (designObjParameter.type == "ungroup") {
                return;
            }
            currentPOM[designObjParameter.name] = [];
            currentPOM[designObjParameter.name].designObjParameter = designObjParameter;
            var array_length;
            if ('array_size' in designObjParameter && designObjParameter.array_size != null && designObjParameter.array_size != "") {
                array_length = Math.round(eval(designObjParameter.array_size));
                currentPOM[designObjParameter.name].array_size = designObjParameter.array_size;
            } else {
                array_length = 1;
            }
            for (var array_par = 0; array_par < array_length ; array_par++) {
                createParameterArrayElement(currentPOM, designObjParameter, array_par, array_length, level);
            }
            // *** pending verigy it can be used here
            evalText = evalPOMvalues(POM, false, null, 0, "", null, null, false);  // createIfArrayChange = false (we are building the POM);
            eval(evalText);
            parameter_index++;
        }
        if (level == 0) { // end of the process
            if (console_flag) console.log("POM");
            if (console_flag) console.log("Object: " + currentPOM);
        }
    }
    function createParameterArrayElement(currentPOM, designObjParameter, array_p, array_length, level) {
                if ( designObjParameter.type == "m"       || designObjParameter.type == "cm"
                  || designObjParameter.type == "u"       
                  || designObjParameter.type == "options" || designObjParameter.type == "materials"
                  || designObjParameter.type == "formula" || designObjParameter.type == "internal") {
                    currentPOM[designObjParameter.name][array_p] = JSON.parse(JSON.stringify(designObjParameter));
                    currentParameter = currentPOM[designObjParameter.name][array_p];
                    if (objectPOM != null) {
                        currentParameter.value = objectPOM[designObjParameter.name][array_p].value;
                    } else {
                        if (isNaN(currentParameter.default)) {
                            if (currentParameter.default != null) {
                                if (currentParameter.default.startsWith("'")) {
                                   currentParameter.value = currentParameter.default;
                                } else {
                                    //currentParameter.value = eval(currentParameter.default);
                                    currentParameter.value = (currentParameter.default);
                                }
                            }
                        } else {
                            currentParameter.value = eval(currentParameter.default);
                        }
                    }
                    if ( (designObjParameter.type == "options" || designObjParameter.type == "materials") && currentParameter.value == null) {
                        currentParameter.value = currentParameter.options[0][1];  // value of the first [0] option
                    }
                } else if (designObjParameter.type == "group") {
                    if (designObjParameter.parameter_init_group == null) {
                        designObjParameter.parameter_init_group = parameter_index;
                    } else {
                        parameter_index = designObjParameter.parameter_init_group;
                    }
                    currentPOM[designObjParameter.name][array_p] = {};
                    currentPOM[designObjParameter.name][array_p].type = "group";
                    parameter_index++;
                    createParametersObjectModel(currentPOM[designObjParameter.name][array_p], level + 1);
                    /*
                    if (array_i < array_length - 1) {  // not the last one
                        parameter_index = designObjParameter.parameter_init_group;
                    }
                    */
             //   } else if (designObjParameter.type == "ungroup") {
             //       return;
                }
    }

    function createGuiFromPOM(currentPOM, currentFolder, level) {

        // Material panel
        if (level == 0) {  // void previous materialPanel
            // Material panel
            var materialPanel = document.getElementById("materialPanel");
            materialPanel.innerHTML = "";  
        }

        for (var parameterName in currentPOM){
          if (Object.prototype.hasOwnProperty.call(currentPOM, parameterName)
                && typeof currentPOM[parameterName] == "object") {
            if (console_flag) console.log(parameterName);
            var parameter = currentPOM[parameterName];
            if (!(parameter.designObjParameter.hidden != null && parameter.designObjParameter.hidden == "true")) {
                //var designObjParameter = currentPOM[parameterName].designObjParameter;
                var array_length;
                if (parameter.array_size_value != null) {
                    array_length = parameter.array_size_value;
                } else {
                    array_length = parameter.length;
                }
                for (var array_p = 0; array_p < array_length ; array_p++) {
                    var parameterName_array_i;
                    if (array_length == 1) {
                        parameterName_array_i = parameterName
                    } else {
                        parameterName_array_i = parameterName + " " + (array_p + 1);
                    }
                    if (parameter[array_p].type == "m" ||
                        parameter[array_p].type == "cm" ||
                        parameter[array_p].type == "u") {
                            currentFolder.add( parameter[array_p], "value", Number(parameter[array_p].min),
                              Number(parameter[array_p].max)).step(Number(parameter[array_p].step) || 1).name(parameterName_array_i)
                              .onChange( updateMeasures);
                    } else if (parameter[array_p].type == "options" || parameter[array_p].type == "materials") {
                        var optionsObject = {};
                        if (parameter[array_p].type == "materials") {
                            // Material panel
                            var divEl = document.createElement("DIV");
                            divEl.setAttribute("id", "material_property_" + parameterName_array_i);
                            document.getElementById("materialPanel").appendChild(divEl);
                        }
                        for (j = 0;j<parameter[array_p].options.length; j++) {
                            optionsObject[parameter[array_p].options[j][0]] = parameter[array_p].options[j][1];
                            if (parameter[array_p].type == "materials") {
                                // Material panel
                                var divEl = document.createElement("DIV");
                                divEl.setAttribute("class", "material_option");
                                var span1El = document.createElement("SPAN");
                                var text1Node = document.createTextNode(parameter[array_p].options[j][0]);
                                divEl.appendChild(span1El);
                                span1El.appendChild(text1Node);
                                document.getElementById("material_property_" + parameterName_array_i).appendChild(divEl);
                                // set texture image
                                var materialElement = getMaterial(parameter[array_p].options[j][1]);
                                if (materialElement != null && materialElement.texture != null) {
                                    divEl.setAttribute("style", "background-image: url('" + materialElement.texture + "'); background-size: 100%;");
                                    //divEl.setAttribute("onclick", "window.open('" + materialElement.texture + "');");
                                }
                                divEl.setAttribute("onclick", "setMaterialFromPanel('" + parameterName + "', " +  array_p + ", '" + parameter[array_p].options[j][1] + "')");
                            }
                        }
                        currentFolder.add( parameter[array_p], "value", optionsObject ).name(parameterName_array_i).onChange( updateMeasures);;
                    } else if (parameter[array_p].type == "formula" || parameter[array_p].type == "internal") {
                        currentFolder.add( parameter[array_p], "value").name(parameterName_array_i);
                    } else if (parameter[array_p].type == "group") {
                        var newFolder = currentFolder.addFolder(parameterName_array_i);
                        createGuiFromPOM(parameter[array_p], newFolder, level + 1);
                    } else if (parameter[array_p].type == "ungroup") {
                        return;
                    }
                }
            }
          }
        }
        if (level == 0) {
            API["Order"] = orderPOM;
            currentFolder.add( API, "Order").name( 'Order' );
        }
    }
    function orderPOM (){
       var txt;
       var order = JSON.stringify(POM);
       var customer = prompt( "You are going to save an order\nPlease enter your email or phone");
       if (customer == null || customer == "") {
        return;
      } else {
        saveOrder(customer, order);
      }
    }
    async function saveOrder(customer, order) {
        name = "collection "+ (document.getElementById("collectionsList").childElementCount + 1.0);
        params1 = {}
        params1.company  = companyId;
        params1.customer = customer;
        params1.collectionId = collectionId;
        params1.objectId = designObj.id;  // changed from designName to objectId
        params1.data = order;
        const result = await Parse.Cloud.run('createOrder', params1);
        console.log("order created ", result);
    }

    function setMaterialFromPanel(parameterName, array_p, parameterValue) {
        POM[parameterName][array_p].value = parameterValue;
        updateMeasures();
    }
    
    var arrayFormRows;    
    
    function createParametersModuleArrayForm(parentDiv, arrayProperties, arrayPropertiesValues) {
        if (console_flag) console.log("createParametersModuleArrayForm");

        // properties for module
        for (var ipar =0; ipar< arrayProperties.length; ipar++) {
                var propertyName = arrayProperties[ipar].name;
                var propertyValue;
                if (arrayPropertiesValues == null) {
                    propertyValue = ""; //***
                } else {
                    var propertyElement = getArrayElementByName(arrayPropertiesValues, propertyName);
                    if (propertyElement != null) {
                        propertyValue = getArrayElementByName(arrayPropertiesValues, propertyName).default;
                    } else {
                        propertyValue = "";
                    }
                }
                var divEl = document.createElement("DIV");
                divEl.setAttribute("class", "module property");
                var span1El = document.createElement("SPAN");
                var text1Node = document.createTextNode(propertyName);
                divEl.appendChild(span1El);
                span1El.appendChild(text1Node);
                var span2El = document.createElement("INPUT");
                span2El.setAttribute("id", "property_" + propertyName);
                span2El.setAttribute("class", "property");
                span2El.value = propertyValue;
                //oninput
                span2El.oninput=function() {elementOninput(this)};
                divEl.appendChild(span2El);
                parentDiv.appendChild(divEl);

            
        }
    }
    function getArrayElementById(array, id) {
        for (var i =0; i< array.length; i++) {
            if (id == array[i].id) {
                return array[i];
            }
        }
        return null;  // name not found 
    }
    function getArrayElementByName(array, name) {
        for (var i =0; i< array.length; i++) {
            if (name == array[i].name) {
                return array[i];
            }
        }
        return null;  // name not found 
    }

    function createArrayForm(parentDiv, arrayValue, divId, headerCell, headerArray, rowTitle, inputNames, voidArray, voidLenghtArray, lengthName ) {
        if (console_flag) console.log("createArrayForm");
        arrayFormRows = 0;
        var divEl = document.createElement("DIV");
        divEl.setAttribute("id", divId);
        parentDiv.appendChild(divEl);
        divEl.appendChild(createArrayHeader(headerCell, headerArray));
        if (arrayValue == null || arrayValue == "") {
            /* show three void rows 
            createRowOfArrayForm(divId, inputNames, voidArray, rowTitle);
            createRowOfArrayForm(divId, inputNames, voidArray, rowTitle);
            createRowOfArrayForm(divId, inputNames, voidArray, rowTitle);
        } else {
            */
            /* default data
            */
            if (divId == "materialsForm") {
                arrayValue = [["default","default"]];
            } else  {
                arrayValue = [["0","0"],["2","0"],["1.5","0.5"],["0.5","0.5"]];
            }
        }
            for (var k =0; k< arrayValue.length; k++) {
                createRowOfArrayForm(divId, inputNames, arrayValue[k], rowTitle);
            }
        //}
        var buttonLineEl = document.createElement("BUTTON");   //  <-***
        buttonLineEl.setAttribute("id", "addArrayRow");
        buttonLineEl.setAttribute("onClick", "createRowOfArrayForm('" + divId + "', " + JSON.stringify(inputNames) + ", "
          +  JSON.stringify(voidArray) + ", '" + rowTitle + "')");
        var t = document.createTextNode("Add Row");
        buttonLineEl.appendChild(t);
        divEl.appendChild(buttonLineEl);
        if (voidLenghtArray != null) {  // second button of "Add curve" for Bezier curves
            var buttonCurveEl = document.createElement("BUTTON");
            buttonCurveEl.setAttribute("id", "addArrayRow2");
            buttonCurveEl.setAttribute("onClick", "createRowOfArrayForm('" + divId + "', " + JSON.stringify(inputNames) + ", "
              +  JSON.stringify(voidLenghtArray) + ", '" + rowTitle + "')");
            var t = document.createTextNode(lengthName);
            buttonCurveEl.appendChild(t);
            divEl.appendChild(buttonCurveEl);
        }
        
        return divEl
    }

    function createRowOfArrayForm(divId, rowName, rowValue, rowTitle) {
        arrayFormRows++;
        var divEl = document.createElement("DIV");
        var span1El = document.createElement("SPAN");
        var text1Node = document.createTextNode(rowTitle + " " + arrayFormRows);
        span1El.appendChild(text1Node);
        divEl.appendChild(span1El);
        
        for (i_point = 0; i_point < rowValue.length; i_point++) {
            if (divId == "materialsForm" && rowName[i_point] == "op_value") {  // for materials, create a SELECT
                var selectEl = document.createElement("SELECT");
                point_id = rowName[i_point] + "_" + arrayFormRows;
                point_id_prev = rowName[i_point - 1] + "_" + arrayFormRows;
                selectEl.setAttribute("id", point_id);
                selectEl.setAttribute("id_name", point_id_prev);
                for (var i_mat =0; i_mat< materialArr.length; i_mat++) {
                    var option = document.createElement("option");
                    option.text  = materialArr[i_mat].name;
                    option.value = materialArr[i_mat].id;
                    selectEl.add(option);
                }
                selectEl.value = rowValue[i_point];
                //materialArr[i_mat].name
                selectEl.oninput=function() {setDefaultName(this); elementOninput(this)};
                divEl.appendChild(selectEl);
            } else {  // for not materials
                var spanXEl = document.createElement("INPUT");
                point_id = rowName[i_point] + "_" + arrayFormRows;
                spanXEl.setAttribute("id", point_id);
                spanXEl.setAttribute("class", "point");
                spanXEl.value = rowValue[i_point];
                //oninput
                spanXEl.oninput=function() {elementOninput(this)};
                divEl.appendChild(spanXEl);
            }
        }
              
        document.getElementById(divId).appendChild(divEl);
        buttonAdd = document.getElementById("addArrayRow");
        if (buttonAdd != null) {
            document.getElementById(divId).appendChild(buttonAdd); // move to the end of the points
        }
        buttonAdd = document.getElementById("addArrayRow2");
        if (buttonAdd != null) {
            document.getElementById(divId).appendChild(buttonAdd); // move to the end of the points
        }
        // update size because it has maxHeight
        var panelDiv = divEl.parentNode.parentNode.parentNode.parentNode;
        panelDiv.style.maxHeight = panelDiv.scrollHeight + "px";

        return divEl
    }
    
    function setDefaultName(selectEl) {
        document.getElementById(selectEl.getAttribute("id_name")).value = selectEl.options[selectEl.selectedIndex].text;
    }
    function createArrayHeader(headerCell, headerArray) {
        var divEl = document.createElement("DIV");
        var span1El = document.createElement("SPAN");
        var text1Node = document.createTextNode(headerCell);
        span1El.appendChild(text1Node);
        divEl.appendChild(span1El);
        for (var i_header = 0; i_header < headerArray.length; i_header++) {
            var span1El = document.createElement("SPAN");
            var text1Node = document.createTextNode(headerArray[i_header]);
            span1El.setAttribute("class", "arrayHeader");
            span1El.appendChild(text1Node);
            divEl.appendChild(span1El);
        }
        return divEl
    }
    
    function addHiddenField(name, value) {
        var hiddenEl = document.createElement("INPUT");
        hiddenEl.setAttribute("id", name);
        hiddenEl.setAttribute("type", "text");  // text for debugger, hidden for profuction
        hiddenEl.value = value;
        return hiddenEl;
    }
    function updateObject() {
        if (console_flag) console.log("editObject");
        var formEl = document.getElementById("editObject");
        
        var sys_type = document.getElementById("sys_type").value;
        var sys_object = document.getElementById("sys_object").value;
        var sysObjectDesign = getArrayElementByName(designArr_final, sys_object);
        var objectArray;
        if (sys_type == "sys_parameter") {
            objectArray = sysObjectDesign.parameters;
            properties = parameterProperties;
        } else if (sys_type == "sys_piece") {
            objectArray = sysObjectDesign.pieces;
            type = document.querySelector("div#editObject #type").value;
            if (type == null || type == "") type = "Box";
            properties = pieceProperties[type];
        } else if (sys_type == "sys_subsystem_parameter") {
            var sys_element = document.getElementById("sys_element").value;
            if (!Array.isArray(sysObjectDesign.pieces[sys_element]["parameters"])) {  // create the array for the parameters
                sysObjectDesign.pieces[sys_element]["parameters"] = [];
            }
            objectArray = sysObjectDesign.pieces[sys_element]["parameters"];
            properties = subsystemParameterProperties;
        } else if (sys_type == "sys_material") {
            objectArray = materialArr;
            properties = materialProperties;
        } else if (sys_type == "sys_collectionObject") {
            objectArray = designArr_final;
            properties = objectPropertiesTable;
        } else {
            if (console_flag) console.log("sys_type: " + sys_type + " not defined *********");
        }

        pieceObj = {}
        var sys_formType = document.getElementById("sys_formType").value;
        var sys_array = document.getElementById("sys_array").value;

        for (var j =0; j< properties.length; j++) {
            var propertyName  = properties[j];
            if (sys_type == "sys_piece" && propertyName == "shape_array") {
                if (console_flag) console.log("updateObject shape_array");
                shapeArray = readShapeArray();
                pieceObj[propertyName] = shapeArray;
            } else if (sys_type == "sys_piece" && propertyName == "parameters") {
                if (console_flag) console.log("updateObject parameters"); //***
                var subsystem_value = document.getElementById("subsystem").value;

                if (subsystem_value.startsWith("parameter:")) {
                    /*
                    var evalParameters = getEvalParameters(designArr[sys_object].parameters); // *** correct parameters?
                    eval(evalParameters);
                    subsystem_value = eval(subsystem_value.substring(10));  // 
                    if (console_flag) console.log("evalParameters subsystem_value: " + subsystem_value);
                    */
                    arrayProperties = getParametersOfModuleOption(sys_object, subsystem_value.substring(10));
                } else {
                    arrayProperties = getArrayElementById(designArr_final, subsystem_value).parameters;
                }
                
                pieceObj.parameters=[];
                for (var ipar =0; ipar< arrayProperties.length; ipar++) {
                    pieceObj.parameters[ipar] = {};
                    property_name = arrayProperties[ipar].name;
                    pieceObj.parameters[ipar].name    = property_name;
                    var propertyFieldValue = "";
                    if (document.getElementById("property_" + property_name) != null) {
                        propertyFieldValue = document.getElementById("property_" + property_name).value;
                    }
                    pieceObj.parameters[ipar].default = propertyFieldValue;
                }
            } else if (sys_type == "sys_parameter" && propertyName == "options") {
                if (console_flag) console.log("updateObject shape_array");
                optionsArray = readOptionsArray();
                pieceObj[propertyName] = optionsArray;
            } else {
                field = document.querySelector("div#editObject #" + propertyName);
                var propertyValue = null;
                if (field != null) {
                    propertyValue  = field.value;
                }
                if (propertyValue != "") {  // not set void properties
                    if (propertyName == "parameters") {  // not update parameters 
                        if (sys_formType != "N") {
                            pieceObj[propertyName] = objectArray[sys_array]["parameters"];  // get the parameters from the original
                        }
                    } else {
                        pieceObj[propertyName] = propertyValue;
                    }
                }
                // Perpendicular property
                if (sys_type == "sys_piece" && propertyName.startsWith("material_")) {
                    field = document.querySelector("div#editObject #" + propertyName + "_Perpendicular");
                    var propertyValue = null;
                    if (field != null) {
                        //propertyValue  = field.value;
                        propertyValue  = field.checked;
                    }
                    if (propertyValue != "") {
                        pieceObj[propertyName + "_Perpendicular"] = propertyValue;
                    }
                }
            }
        }
        if (console_flag) console.log("object created");
        if (sys_formType == "E") {
            pieceObj.array = objectArray[sys_array].array;
            if (sys_type == "sys_material") {
                pieceObj.id = objectArray[sys_array].id;
            }
            if (sys_type == "sys_collectionObject") {
                pieceObj.id = objectArray[sys_array].id;
                pieceObj.parameters = objectArray[sys_array].parameters;
                pieceObj.pieces = objectArray[sys_array].pieces;
            }
            objectArray[sys_array] = pieceObj;
        } else if (sys_formType == "D" || sys_formType == "N"){
            if (sys_type == "sys_material" || sys_type == "sys_collectionObject") {
                pieceObj.id = randomString(10);
            }
            if (sys_type == "sys_collectionObject") {
                pieceObj.parameters = [];
                pieceObj.pieces = [];
            }
            objectArray.push(pieceObj);
            document.getElementById("sys_formType").value = "E";  // So next Save don't create new elements
            document.getElementById("sys_array").value = objectArray.length - 1;  // So next Save don't create new elements
        } else {
            if (console_flag) console.log("sys_formType: " + sys_formType + " not defined *********");
        }
        createParametersObjectModel(POM, 0);
        updateMeasures();
    }
    function updateObjectClose() {
        updateObject();
        var sys_type = document.getElementById("sys_type").value;
        var sys_object = document.getElementById("sys_object").value;
        if (sys_type == "sys_subsystem_parameter") {
            createTableSusbsystemParameter(document.getElementById("sys_element").value, sys_object, "obj_subsystem_parameter");
        } else if (sys_type == "sys_material") {
            printMaterialTable();
        } else if (sys_type == "sys_collectionObject") {
            printObjectsTable();
        } else {
        // move renderDiv to beggining of body
            var divEl = document.getElementById("renderDiv");
            document.body.insertBefore(divEl, document.body.firstChild);
            onWindowResize();
            //printModelTable(sys_object, getArrayElementByName(designArr_final, sys_object));
            printModelTable(getArrayElementByName(designArr_final, sys_object));
        }
    }
    function readParametersModuleArrayForm(parentDiv, arrayProperties, arrayPropertiesValues) { // ***

        // properties for module
        for (var ipar =0; ipar< arrayProperties.length; ipar++) {
                var propertyName = arrayProperties[ipar].name;
                var propertyValue;
                if (arrayPropertiesValues == null) {
                    propertyValue = ""; //***
                } else {
                    propertyValue = getArrayElementByName(arrayPropertiesValues, propertyName).default;
                }
                var divEl = document.createElement("DIV");
                var span1El = document.createElement("SPAN");
                var text1Node = document.createTextNode(propertyName);
                divEl.appendChild(span1El);
                span1El.appendChild(text1Node);
                var span2El = document.createElement("INPUT");
                span2El.setAttribute("id", propertyName);
                span2El.setAttribute("class", "property");
                span2El.value = propertyValue;
                divEl.appendChild(span2El);
                parentDiv.appendChild(divEl);

            
        }
    }
    function readShapeArray() {
        shapeArray = [];
        for (var k =1; k<= arrayFormRows; k++) {
            point = [];
            xValue = document.getElementById("x_" + k);
            yValue = document.getElementById("y_" + k);
            if (xValue != null && yValue != null && xValue.value != "" && yValue.value != "") {
                point[0] = xValue.value;
                point[1] = yValue.value;
                // "c1x", "c1y","c2x","c2y"
                c1xValue = document.getElementById("c1x_" + k);
                if (c1xValue != null && c1xValue.value != "") point[2] = c1xValue.value;
                c1yValue = document.getElementById("c1y_" + k);
                if (c1yValue != null && c1yValue.value != "") point[3] = c1yValue.value;
                c2xValue = document.getElementById("c2x_" + k);
                if (c2xValue != null && c2xValue.value != "") point[4] = c2xValue.value;
                c2yValue = document.getElementById("c2y_" + k);
                if (c2yValue != null && c2yValue.value != "") point[5] = c2yValue.value;

                shapeArray.push(point);
            }
        }
        return shapeArray;
    }
    function readOptionsArray() {
        optionsArray = [];
        for (var k =1; k<= arrayFormRows; k++) {
            option = [];
            nameValue  = document.getElementById("op_name_" + k);
            valueValue = document.getElementById("op_value_" + k);
            if (nameValue != null && valueValue != null && nameValue.value != "" && valueValue.value != "") {
                option[0] = nameValue.value;
                option[1] = valueValue.value;
                optionsArray.push(option);
            }
        }
        return optionsArray;
    }
    function render() {
        renderer.render( scene, camera );
    }


    function onWindowResize() {
        console.debug("Resize window: " + window.innerWidth + " " + window.innerHeight);
        if (camera == null) return;  // not defined 3D view yet

        var divEl = document.getElementById("renderDiv");  // get renderDiv before delete formArea
        if (divEl == null) {
            return;
        }
        if (console_flag) console.log("Parent div:" + divEl.parentNode.id);
        
        /*
        if (divEl.parentNode.id && divEl.parentNode.id == "renderArea") {
            var renderDivEl = divEl.parentNode; // #renderArea
            rendererWidth  = renderDivEl.offsetWidth - 8;
            rendererHeight = renderDivEl.offsetHeight- 8;
        } else {
            setRendererWidthHeight();
        }
        console.debug("Resize div: " + rendererWidth + " " + rendererHeight);
        camera.aspect = rendererWidth / rendererHeight;
        //renderer.setPixelRatio( rendererWidth / rendererHeight);
        camera.updateProjectionMatrix();
        renderer.setSize( rendererWidth, rendererHeight);
        */
        if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }
        render();

    }
    function resizeRendererToDisplaySize(renderer) {  // explained in https://threejs.org/manual/#en/responsive
      const canvas = renderer.domElement;
      const parentElement = canvas.parentElement.parentElement.parentElement  // 
      const pixelRatio = window.devicePixelRatio;
      const width  = parentElement.clientWidth  * pixelRatio | 0;
      const height = window.innerHeight * pixelRatio | 0;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, true);
      }
      return needResize;
    }
    function setRendererWidthHeight() {
        rendererWidth  = window.innerWidth;
        rendererHeight = window.innerHeight - bottomSpace;
    }
    function moveRenderDivUp(divEl) {
        // move renderDiv to beggining of body
        document.body.insertBefore(divEl, document.body.firstChild);
        onWindowResize();
    }
    function cancelEdit() {
        var divEl = document.getElementById("renderDiv");
        //moveRenderDivUp(divEl);
        var formEl = document.getElementById("editObject");
        if (formEl != null) {
            formEl.remove();
        }
    }
</script>
<script>
    Split(['#modelDiv', '#renderColumnDiv'], {
    sizes: [30, 70],
    onDrag: function (sizes) {onWindowResize();},
})
</script>

<script>
    function saveMaterial() {
        copyMaterialPropertiesFromEditorToModel(materialGui, getMaterial(currentMaterialName));
        printMaterialTable();
    }
    
    function copyMaterialPropertiesFromEditorToModel(materialSource, materialTarget) {
        materialTarget.color_r = materialSource.color.r;
        materialTarget.color_g = materialSource.color.g;
        materialTarget.color_b = materialSource.color.b;
        materialTarget.emissive_r = materialSource.emissive.r;
        materialTarget.emissive_g = materialSource.emissive.g;
        materialTarget.emissive_b = materialSource.emissive.b;
        materialTarget.roughness = materialSource.roughness;
        materialTarget.metalness = materialSource.metalness;
        materialTarget.reflectivity = materialSource.reflectivity;
        materialTarget.clearcoat = materialSource.clearcoat;
        materialTarget.clearcoatRoughness = materialSource.clearcoatRoughness;
        materialTarget.transparent = materialSource.transparent;
        materialTarget.opacity = materialSource.opacity;
        materialTarget.diffuseMap = materialSource.diffuseMap;
        materialTarget.normalFactor = materialSource.normalFactor;
        materialTarget.envMapIntensity = materialSource.envMapIntensity;
        materialTarget.ior = materialSource.ior;
        materialTarget.wireframe = materialSource.wireframe;
    }
    function copyMaterialPropertiesFromModelToEditor(materialSource, materialTarget, updateController) {
        materialTarget.color.r  = setValueOrDefault(materialSource.color_r, defaultMaterial.color.r);
        materialTarget.color.g  = setValueOrDefault(materialSource.color_g, defaultMaterial.color.g);
        materialTarget.color.b  = setValueOrDefault(materialSource.color_b, defaultMaterial.color.b);
        materialTarget.emissive.r  = setValueOrDefault(materialSource.emissive_r, defaultMaterial.emissive.r);
        materialTarget.emissive.g  = setValueOrDefault(materialSource.emissive_g, defaultMaterial.emissive.g);
        materialTarget.emissive.b  = setValueOrDefault(materialSource.emissive_b, defaultMaterial.emissive.b);
        materialTarget.roughness  = setValueOrDefault(materialSource.roughness, defaultMaterial.roughness);
        materialTarget.metalness  = setValueOrDefault(materialSource.metalness, defaultMaterial.metalness);
        materialTarget.reflectivity  = setValueOrDefault(materialSource.reflectivity, defaultMaterial.reflectivity);
        materialTarget.clearcoat  = setValueOrDefault(materialSource.clearcoat, defaultMaterial.clearcoat);
        materialTarget.clearcoatRoughness  = setValueOrDefault(materialSource.clearcoatRoughness, defaultMaterial.clearcoatRoughness);
        materialTarget.transparent  = setValueOrDefault(materialSource.transparent, defaultMaterial.transparent);
        materialTarget.opacity  = setValueOrDefault(materialSource.opacity, defaultMaterial.opacity);
        materialTarget.diffuseMap  = setValueOrDefault(materialSource.diffuseMap, defaultMaterial.diffuseMap);
        materialTarget.normalFactor  = setValueOrDefault(materialSource.normalFactor, defaultMaterial.normalFactor);
        materialTarget.envMapIntensity  = setValueOrDefault(materialSource.envMapIntensity, defaultMaterial.envMapIntensity);
        materialTarget.ior  = setValueOrDefault(materialSource.ior, defaultMaterial.ior);
        materialTarget.wireframe  = setValueOrDefault(materialSource.wireframe, defaultMaterial.wireframe);
        var materialColor = materialTarget.color.getHex();
        if (materialColor != null) {
            materialData.color = materialTarget.color.getHex()
        }
        var materialEmissiveColor = materialTarget.emissive.getHex();
        if (materialEmissiveColor != null) {
            materialData.emissive = materialTarget.emissive.getHex()
        }
        if (updateController) {
            if (user_rol >= 2) {
                var materialsFolder = getGuiFolderByName(gui.folders, "Material properties");
                uptadeControllers(materialsFolder);
            }
        }
    }

    function setValueOrDefault(definedValue, defaultValue) {
        if (definedValue != null) {
            return eval(definedValue);  // convert "true" to true
        } else {
            return eval(defaultValue);
        }
    }
    function updatePhysicalMaterial() {
        materialEdit.color.r = materialGui.color.r;
        materialEdit.color.g = materialGui.color.g;
        materialEdit.color.b = materialGui.color.b;
        materialEdit.emissive.r = materialGui.emissive.r;
        materialEdit.emissive.g = materialGui.emissive.g;
        materialEdit.emissive.b = materialGui.emissive.b;
        materialEdit.roughness = materialGui.roughness;
        materialEdit.metalness = materialGui.metalness;
        materialEdit.reflectivity = materialGui.reflectivity;
        materialEdit.clearcoat = materialGui.clearcoat;
        materialEdit.clearcoatRoughness = materialGui.clearcoatRoughness;
        materialEdit.transparent = materialGui.transparent;
        materialEdit.opacity = materialGui.opacity;
        if (materialGui.diffuseMap) {
            materialEdit.map = materialEdit.map_backup;
        } else {
            materialEdit.map = null;
        }
        materialEdit.normalScale.x = materialGui.normalFactor;
        materialEdit.normalScale.y = materialGui.normalFactor;
        materialEdit.envMapIntensity = materialGui.envMapIntensity;
        materialEdit.ior = materialGui.ior;
        materialEdit.wireframe = materialGui.wireframe;
        materialEdit.needsUpdate = true ;
        render();
    }
</script>
<script>
            function getMaterial(materialId) {
                for (var i =0; i< materialArr.length; i++) {
                    if (materialId == materialArr[i].id) {
                        return materialArr[i];
                    }
                }
                return null;  // name not found 
            }
            function getPiece(name) {
                for (var i =0; i< designObj.pieces.length; i++) {
                    if (name == designObj.pieces[i].name) {
                        return designObj.pieces[i];
                    }
                }
                return null;  // name not found 
            }
            
            function isType(obj, objectType) {   // more general check type, can replace the others
                return obj != null && obj.constructor.name === objectType;
            }
            function isObject(obj) {
                return obj != null && obj.constructor.name === "Object"
            }
            function isMesh(obj) {
                return obj != null && obj.constructor.name === "Mesh"
            }
            function isGroup(obj) {
                return obj != null && obj.constructor.name === "Group"
            }
            // the function getEvalParameters() eval from the definition of the object.
            // the function evalPOMvalues() eval parameters from POM Object.
            function getEvalParameters(parameters, previousEvalText){   // Eval parameters from object definition
                eval(previousEvalText);
                //eval("array_i=0;");
                var evalString = "";
                for (var j =0; j< parameters.length; j++) {
                    if (parameters[j].type != "group" && parameters[j].type != "ungroup") {
                        var propertyValue;
                        if (parameters[j].array_size != null && parameters[j].array_size != "") {
                            //eval(parameters[j].name + "=" + "[]");
                            evalString = evalString + parameters[j].name + "=" + "[]" + ";";
                        } else {
                            if (isNaN(parameters[j].default)) {
                                if (parameters[j].default != null) {
                                    if (parameters[j].default.startsWith("'")) {
                                        propertyValue = parameters[j].default;
                                    } else {
                                        propertyValue = eval(parameters[j].default);
                                    }
                                }
                            } else {
                                if (parameters[j].type == "cm") {
                                    propertyValue = eval(parameters[j].default) / 100;
                                } else {
                                    propertyValue = eval(parameters[j].default);
                                }
                            }
                            //eval(parameters[j].name + "=" + propertyValue);
                            evalString = evalString + parameters[j].name + "=" + propertyValue + ";";
                        }
                    }
                }
                return evalString;
            }

            // the function getEvalParameters() eval from the definition of the object.
            // the function evalPOMvalues() eval parameters from POM Object.
            /*
            The function return a JS expression with the variables (ex: v1=13;v2=15;obj[{"a":3}) 
            or if outputInObject is true a JS object: ex: {a:3}
            When it is called from the root node (POM), outputInObject is false and level = 0
              currentPOM: is the node of the POM from the expression will be created
              outputInObject: the function can return the values in the object outputObject if the argument is true, or a text JS expression 
              outputObject: the output of the function is this object if outputInObject is true
              level: firt level is 0, recursive calls add 1 to the level
              evalText: JS expression with the variables until this moment
              rootParameterName: name of th object we are building
              rootParameterObject: is the object created until this moment, it is neccesary to evaluate it 
              createIfArrayChange: we call evalPOMvalues while it is build and after of changes by the final user, when it is build evalPOMvalues doesn't create new elements createIfArrayChange = false.
            */            
            function evalPOMvalues(currentPOM, outputInObject, incomeOutputObject, level, evalText, rootParameterName, rootParameterObject, createIfArrayChange){
                var evalPOMvaluesText = evalText;
                /*
                */
                var output;   // for the top level, the output is a list of variables separated by ";" for other levels is an object
                for (var parameterName in currentPOM){
                    var parameterValue;
                    var parameterEval;
                    if (Object.prototype.hasOwnProperty.call(currentPOM, parameterName)
                          && typeof currentPOM[parameterName] == "object") {
                        if (console_flag) console.log(parameterName);
                        eval(evalPOMvaluesText);
                        if (rootParameterObject != null) {
                            eval(rootParameterName + "=" + JSON.stringify(rootParameterObject) + ";");
                        }
                        var parameter = currentPOM[parameterName];
                        var designObjParameter = currentPOM[parameterName].designObjParameter;

                        if (parameter.array_size != null && parameter.array_size != "") {  // create array of values
                            if (console_flag) console.log("define array for " + parameterName);
                            var array_length = parameter.array_size_value;
                            var arrayValues = [];
                            //eval(evalPOMvaluesText);

                            var new_array_length = eval(parameter.array_size);
                            if (array_length != new_array_length) {
                                changePOMarrayLength = true;
                                parameter.array_size_value = new_array_length;
                                array_length = new_array_length;
                            }
                            if (designObjParameter.type == "group" && rootParameterObject == null) {  // previous one is not object
                                rootParameterObject = arrayValues;
                                rootParameterObject.created = Date.now();
                                rootParameterName = parameterName;
                                //rootParameterObject[parameterName] = arrayValues;
                            }
                            for (var array_p = 0; array_p < array_length ; array_p++) {
                                // for variables used in the same expression
                                var evalString = parameterName + "=" + JSON.stringify(arrayValues) + ";";
                                eval(evalString);
                                if (currentPOM[parameterName][array_p] == null && createIfArrayChange) {
                                    createParameterArrayElement(currentPOM, designObjParameter, array_p, array_length, level);
                                }
                                if (currentPOM[parameterName][array_p] != null) {
    //                            for (var array_p = 0; array_p < array_length ; array_p++) {
                                    if (parameter[array_p].type == "m" ||
                                        parameter[array_p].type == "u") {
                                          parameterEval = parameter[array_p].value;
                                          arrayValues.push(parameterEval);
                                    } else if (parameter[array_p].type == "cm") {
                                          parameterEval = eval(parameter[array_p].value)/100;
                                          arrayValues.push(parameterEval);
                                    } else if (parameter[array_p].type == "options") {
                                          parameterEval = parameter[array_p].value;
                                          arrayValues.push(parameterEval);
                                    } else if (parameter[array_p].type == "materials") {
                                          parameterEval = "'" + parameter[array_p].value + "'";
                                          arrayValues.push(parameterEval);
                                    } else if (parameter[array_p].type == "formula" 
                                            || parameter[array_p].type == "internal") {
                                        var evalArray_i = "array_i" + "=" + array_p + ";";
                                        eval(evalArray_i);
                                        parameterEval = eval(parameter[array_p].default);
                                        parameter[array_p].value = parameterEval;
                                        arrayValues.push(parameterEval);
                                    } else if (parameter[array_p].type == "group") {
                                        var outcomeOutputObject = {}
                                        arrayValues.push(outcomeOutputObject);
                                        evalPOMvaluesTextGroup = evalPOMvaluesText + "array_i" + "=" + array_p + ";";
                                        evalPOMvalues(parameter[array_p], true, outcomeOutputObject, level + 1,   evalPOMvaluesTextGroup, rootParameterName, rootParameterObject, createIfArrayChange);
                                    } else if (parameter[array_p].type == "ungroup") {
                                        return;
                                    }
                                }
                            }
                            //parameterValue = JSON.stringify(arrayValues);
                            if (outputInObject) {
                                parameterValue = arrayValues;
                            } else {
                                parameterValue = JSON.stringify(arrayValues);
                            }
                            //evalText = evalText + parameterName + "=" + JSON.stringify(arrayValues) + ";";
                        } else {            // a simple value of the object
                            if (parameter.length != 1) debugger;
                            //for (var array_p = 0; array_p < array_length ; array_p++) {
                            var array_p = 0;
                            var parameterName_array_i = parameterName;
                            if  (parameter[array_p].type == "m" 
                              || parameter[array_p].type == "u") {
                                parameterEval = eval(parameter[array_p].value);
                            } else if (parameter[array_p].type == "cm") {
                                parameterEval = eval(parameter[array_p].value)/100;
                            } else if (parameter[array_p].type == "options") {
                                parameterEval = parameter[array_p].value;
                            } else if (parameter[array_p].type == "materials") {
                                parameterEval = "'" + parameter[array_p].value + "'";
                            } else if (parameter[array_p].type == "formula"
                                    || parameter[array_p].type == "internal") {
                                parameterEval = eval(parameter[array_p].default);
                                parameter[array_p].value = parameterEval;
                            } else if (parameter[array_p].type == "group") {
                                //parameterValue = evalPOMvalues(parameter[array_p], true, level + 1);
                                if (rootParameterObject == null) {  // previous one is not object
                                    rootParameterObject = {};
                                    rootParameterObject.created = Date.now();
                                    rootParameterName = parameterName;
                                    evalPOMvaluesTextGroup = evalPOMvaluesText + "array_i" + "=" + 0 + ";";
                                }
                                var outcomeOutputObject = {}
                                evalPOMvalues(parameter[array_p], true, outcomeOutputObject, level + 1,
                                  evalPOMvaluesTextGroup, rootParameterName, rootParameterObject, createIfArrayChange);
                                if (outputInObject) {
                                    parameterEval = eval(outcomeOutputObject);
                                } else {
                                    parameterEval = JSON.stringify(outcomeOutputObject);
                                }
                            } else if (parameter[array_p].type == "ungroup") {
                                return;
                            }
                            parameterValue = parameterEval;
                            //}
                        }
                        if (outputInObject) {
                            incomeOutputObject[parameterName] = parameterValue;
                        } else {
                            evalPOMvaluesText = evalPOMvaluesText + parameterName + "=" + parameterValue + ";";
                        }
                    }
                }
                if (outputInObject) {
                    return;
                } else {
                    return evalPOMvaluesText;
                }

            }
            
            function updatePOMformulas(currentPOM, level, evalText){  
                eval(evalText);
                for (var parameterName in currentPOM){
                    if (Object.prototype.hasOwnProperty.call(currentPOM, parameterName)
                          && typeof currentPOM[parameterName] == "object") {
                        if (console_flag) console.log(parameterName);
                        var parameter = currentPOM[parameterName];
                        var array_length = parameter.length;
                        for (var array_p = 0; array_p < array_length ; array_p++) {
                            var parameterName_array_i;
                            if (array_length == 1) {
                                parameterName_array_i = parameterName
                            } else {
                                parameterName_array_i = parameterName + "_" + (array_p + 1);
                            }
                            if (parameter[array_p].type == "formula" || parameter[array_p].type == "internal") {
                                parameter[array_p].value = eval(parameter[array_p].default);
                                if (parameter.array_size != null && parameter.array_size != "") {
                                    eval(parameterName + "[" + array_p + "]=" + parameter[array_p].value + ";");
                                }
                            } else if (parameter[array_p].type == "group") {
                                updatePOMformulas(parameter[array_p], level + 1);
                            }
                        }
                    }
                }
                return;
            }


            function updateUvTransform(arg) {
                    if (textureEdit != null) {
                        var texture = textureEdit;
                        updateUvTransformTexture(texture);
                    }
                    if (roughnessMapTextureEdit != null) {
                        updateUvTransformTexture(roughnessMapTextureEdit);
                    }
                    if (normalTextureEdit != null) {
                        updateUvTransformTexture(normalTextureEdit);
                    }
                    render();
            }

            function updateUvTransformTexture(texture) {
                var size_x = texture.material.size_x;
                var size_y = texture.material.size_y;
                if (size_x == null) size_x = 1;
                if (size_y == null) size_y = 1;
                var angle;
                if (texture.material.angle  != null) {
                    angle = eval(texture.material.angle) * Math.PI / 180.  ;
                } else {
                    angle = 0;
                }
                if ( texture.matrixAutoUpdate === true ) {

                    texture.offset.set( API.offsetX, API.offsetY );
                    texture.repeat.set( API.repeatX, API.repeatY );
                    texture.center.set( API.centerX, API.centerY );
                    texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]

                } else {

                    // one way...
                    //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );

                    // another way...
                    texture.matrix
                        .identity()
                        .translate( - API.centerX,- API.centerY, 0 )
                        .rotate( API.rotation + angle)					// I don't understand how rotation can preceed scale, but it seems to be required...
                        .scale( API.repeatX / size_x, API.repeatY / size_y, API.repeatZ )
                    //    .translate( API.centerX, API.centerY )
                        .translate( API.offsetX, API.offsetY, 0 )
                        ;

                }
            }

            function updateMeasures(){
                printTime("initialize updateMeasures");
                evalText = evalPOMvalues(POM, false, null, 0, "", null, null, true);  // eval before formulas to avoid glitch in render
                //updatePOMformulas(POM, 0, evalText);
                evalText = "";
                evalText = evalPOMvalues(POM, false, null, 0, "", null, null, true);
                designObj.evalText = "var context='main';" + evalText;
                updateMeasuresAPI(scene, THREE, API, designObj);
                updateUvTransform();
                render();
                if (gui != null) {
                    API.renders ++;
                    
                    /*
                    replaced by updatePOMformulas
                    for (var i =0; i< designObj.parameters.length; i++) {
                        if (designObj.parameters[i].type == "internal" || designObj.parameters[i].type == "formula") {
                            var res = evalContext(designObj.parameters[i].default );
                            if (console_flag) console.log("eval formula: " + res);
                            API[designObj.parameters[i].name] = res;
                        }
                    }
                    //API.price = Math.round(eval('alto*largo*200'));
                    */
                    

                    uptadeControllers(gui);
                    uptadeControllers(guiParametersFolder);
                    if (user_rol >= 3) {
                        var settingsFolder = getGuiFolderByName(gui.folders, "settings");
                        uptadeControllers(settingsFolder);
                    }
                }
                printTime("end updateMeasures");
            }
            
            function uptadeControllers(guiFolder) {
                for (var j = 0; j < guiFolder.controllers.length; j++ ) {
                    guiFolder.controllers[j].updateDisplay();
                }
            }
            
            function getGuiFolderByName(folders, folderName) {
                var result = folders.filter(obj => {
                    return obj._title === folderName;
                })
                return result? result[0] : null;
            }
            
            var currentMaterialName = null;
            var previousMaterialName = null;
            var materialEdit;
            var textureEdit;
            var roughnessMapTextureEdit;
            var normalTextureEdit;
            function setMaterial(){
                var materialName = API["Materials"];
                previousMaterialName = currentMaterialName;
                currentMaterialName = materialName;
                if (console_flag) console.log("currentMaterialName: " + currentMaterialName);
                if (console_flag) console.log("previousMaterialName: " + previousMaterialName);
                if (previousMaterialName != null) {
                    var previousMat = getMaterial(previousMaterialName);
                    materialEdit = previousMat.material;
                    textureEdit = previousMat.material.map;
        //            textureEdit_backup = previousMat.material.map_backup;
                    roughnessMapTextureEdit = previousMat.material.roughnessMap;
                    normalTextureEdit = previousMat.material.normalMap;
                    copyMaterialPropertiesFromModelToEditor(previousMat, materialGui, true);  // this restore the modifications if not saved with saveMaterial()
                    updatePhysicalMaterial();
                }
                var mat = getMaterial(currentMaterialName);
                materialEdit = mat.material;
                textureEdit = mat.material.map;
        //        textureEdit_backup = mat.material.map_backup;
                roughnessMapTextureEdit = mat.material.roughnessMap;
                normalTextureEdit = mat.material.normalMap;
                copyMaterialPropertiesFromModelToEditor(mat, materialGui, true);
                updatePhysicalMaterial();
                if (materialOverride != null) {
                    setUVSubsystem(designObj, flagSetMaterialAll);
                    render();
                }
            }

            function setUVSubsystem(designSubsystem, setMaterialAll) {
                if (setMaterialAll) {
                    // use for material UV or any material selected in Materials Select
                    if (currentMaterialName == null) {
                        materialOverride = material_UV;
                    } else {
                        materialOverride = getMaterial(currentMaterialName).material;
                    }
                    for (var i = 0; i< designSubsystem.pieces.length; i++) {
                        for (var j = 0; j < designSubsystem.pieces[i].array.length ; j++) {
                            designSubsystem.pieces[i].array[j].mesh.materialOriginal = designSubsystem.pieces[i].array[j].mesh.material;
                            designSubsystem.pieces[i].array[j].mesh.material = materialOverride; // material_UV;
                            designSubsystem.pieces[i].array[j].mesh.setUV = true;
                            if ('subsystem' in designSubsystem.pieces[i]) {
                                setUVSubsystem(designSubsystem.pieces[i].array[j].subsystemDesign, setMaterialAll);
                            }
                        }
                    }
                } else {
                    materialOverride = null;
                    for (var i = 0; i< designSubsystem.pieces.length; i++) {
                        for (var j = 0; j < designSubsystem.pieces[i].array.length ; j++) {
                            designSubsystem.pieces[i].array[j].mesh.material = designSubsystem.pieces[i].array[j].mesh.materialOriginal;
                            designSubsystem.pieces[i].array[j].mesh.setUV = false;
                            if ('subsystem' in designSubsystem.pieces[i]) {
                                setUVSubsystem(designSubsystem.pieces[i].array[j].subsystemDesign, setMaterialAll);
                            }
                        }
                    }
                }
            }

            function updateMeasuresAPI(node, THREE, API, updateDesign){
//                updateDesign.eval = makeEvalContext ();
//                updateDesign.eval(evalText);
                eval(updateDesign.evalText);    // initial evalText
                if (console_flag) console.log("eval updateMeasuresAPI: " + updateDesign.name + " " + updateDesign.evalText);
                for (var i =0; i< updateDesign.pieces.length; i++) {

                    // we define the parameters of the subsystem with the values of the updateDesign, but will apply them to the subsystem (before the call to updateMeasuresAPI.
                    //var subsetEvalText = "";
                    // Moved down to "subsetEvalText"

                    var array_length;
                    if ('array_size' in updateDesign.pieces[i]) {
                        array_length = Math.round(eval(updateDesign.pieces[i].array_size));
                    } else {
                        array_length = 1;
                    }
                    if (updateDesign.pieces[i].array == null) {
                        if (console_flag) console.log("Create array for piece " + i + " array_length: " + array_length + " " + updateDesign.name);
                        updateDesign.pieces[i].array = [];
                    }
                  //for (var array_i = 0; array_i < updateDesign.pieces[i].array.length ; array_i++) {
                    for (var array_j = array_length; array_j < updateDesign.pieces[i].array.length ; array_j++) {
                        if (console_flag) console.log("Change visibilit of " + i + " array: " + array_j);
                        updateDesign.pieces[i].array[array_j].mesh.visible = false;
                    }
                    for (var array_piece = 0; array_piece < array_length ; array_piece++) {

                        if (!isObject(updateDesign.pieces[i].array[array_piece])) {
                            if (console_flag) console.log("Create object " + array_piece);
                            updateDesign.pieces[i].array[array_piece] = {}
                        }
                        updateDesign.pieces[i].array[array_piece].meshPositionChange = false;
                        updateDesign.pieces[i].array[array_piece].evalText = updateDesign.evalText + "array_i = " + array_piece + ";" + "array_n = " + array_length + ";";
                        if (console_flag) console.log("eval piece (a): " + i + " "  + updateDesign.name + " evalText: " + updateDesign.pieces[i].array[array_piece].evalText);
                        eval(updateDesign.pieces[i].array[array_piece].evalText);
                        if ('subsystem' in updateDesign.pieces[i]) {
                            var dot;

                            var currentSubsystem;
                            if (updateDesign.pieces[i].subsystem.startsWith("parameter:")) {
                                currentSubsystem = eval(updateDesign.pieces[i].subsystem.substring(10));  // remove "parameter:" String from value
                                if (console_flag) console.log("currentSubsystem: " + currentSubsystem);
                                currentSubsystem = currentSubsystem.replaceAll("'","");
                                if (updateDesign.pieces[i].array[array_piece].previousSubsystemValue != null &&
                                    updateDesign.pieces[i].array[array_piece].previousSubsystemValue != currentSubsystem) {
                                    
                                    // remove dot and mesh
                                    if (updateDesign.pieces[i].array[array_piece].mesh != null) {
                                        node.remove(updateDesign.pieces[i].array[array_piece].mesh);
                                        updateDesign.pieces[i].array[array_piece].mesh = null;
                                    }
                                }
                            } else {
                                currentSubsystem = updateDesign.pieces[i].subsystem;
                            }
                            updateDesign.pieces[i].array[array_piece].previousSubsystemValue = currentSubsystem;

                            if (!isGroup(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create mesh dot");
                                dot = createGroup(THREE);
                                updateDesign.pieces[i].array[array_piece].mesh=dot;
                                if (node == null) debugger;
                                node.add( dot );
                                var clonedDesign = JSON.parse(JSON.stringify(getArrayElementById(designArr_final, currentSubsystem)));
                                updateDesign.pieces[i].array[array_piece].subsystemDesign = clonedDesign;
                            } else {
                                dot = updateDesign.pieces[i].array[array_piece].mesh;
                            }
                          //addDesign(dot, updateDesign.pieces[i].array[array_piece].subsystemDesign);
                            updatePosition(updateDesign, i, array_piece);
                            
                            var subsetEvalText = getEvalParameters(updateDesign.pieces[i].parameters,
                            updateDesign.pieces[i].array[array_piece].evalText);
                            // tried but not has the list of parameters of a piece: var subsetEvalText = evalPOMvalues(POM, "", 0);

                            
                            updateDesign.pieces[i].array[array_piece].subsystemDesign.evalText = "context='" +  
                              updateDesign.pieces[i].name +"';" + subsetEvalText;  // only their parameters, not array_piece
                            if (console_flag) console.log("eval piece (b): " + i + " array_i: " + array_piece 
                              + " subsystem: " + updateDesign.pieces[i].subsystem
                              + " evalText: " + updateDesign.pieces[i].array[array_piece].subsystemDesign.evalText);
                            updateMeasuresAPI(dot, THREE, API, updateDesign.pieces[i].array[array_piece].subsystemDesign);
                            eval(updateDesign.evalText);    // restore evalText
                        //} else if ('gltf' in updateDesign.pieces[i]) {
// Gltf
                        } else if (updateDesign.pieces[i].type == 'Gltf') {
                            if (!isGroup(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Objecto GLTF");
                                const loader = new loaders.GLTFLoader();
                                dot = createGroup(THREE);
                                dot.name = "gltf object"
                                updateDesign.pieces[i].array[array_piece].mesh=dot;
                                if (node == null) debugger;
                                node.add( dot );
                                dot.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                    
                                const addSceneCallback = prepareACallbackFunctionForLoader(dot);
                                loader.load(updateDesign.pieces[i].url,   addSceneCallback, undefined, function ( error ) {
                                    console.error( error );

                                } )
                            }
                            updatePosition(updateDesign, i, array_piece);

// Cylinder 
                        } else if (updateDesign.pieces[i].type == 'Cylinder') {
                            if (!isMesh(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create mesh geometry");
                                geometry = new THREE.CylinderGeometry( 1., 1., 1., 32 );

                                //geometry.translate( 0.5, 0.5, 0.5 ) ;
                                meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 3);
                                mesh = new THREE.Mesh( geometry, meshMaterialArray );
                                if (shadowFlag) {
                                    mesh.castShadow  = true;
                                    mesh.receiveShadow   = true;
                                } else {
                                    mesh.castShadow  = false;
                                    mesh.receiveShadow   = false;
                                }
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_piece].mesh=mesh;
                                updateDesign.pieces[i].array[array_piece].mesh.rt = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.rb = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.lz = 1.;
                                node.add( mesh );
                            }
                            updatePosition(updateDesign, i, array_piece);
// Sphere 
                        } else if (updateDesign.pieces[i].type == 'Sphere') {
                            if (!isMesh(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create mesh geometry");
                                geometry = new THREE.SphereGeometry( 1., 32, 32 );

                                //geometry.translate( 0.5, 0.5, 0.5 ) ;
                                meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 1);
                                mesh = new THREE.Mesh( geometry, meshMaterialArray );
                                if (shadowFlag) {
                                    mesh.castShadow  = true;
                                    mesh.receiveShadow   = true;
                                } else {
                                    mesh.castShadow  = false;
                                    mesh.receiveShadow   = false;
                                }
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_piece].mesh=mesh;
                                updateDesign.pieces[i].array[array_piece].mesh.r = 0.67312;   // random value
                                node.add( mesh );
                            }
                            updatePosition(updateDesign, i, array_piece);
// Triangle 
                        } else if (updateDesign.pieces[i].type == 'Triangle') {
                            if (!isMesh(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create Triangle geometry");
                                
                                const shape = new THREE.Shape();
                                shape.moveTo( 0,0 );
                                shape.lineTo( 0, 1 );
                                shape.lineTo( 1, 0.5 );
                                shape.lineTo( 0, 0 );

                                const extrudeSettings = {
                                    bevelEnabled: false
                                };

                                const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

                                meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 2);
                                mesh = new THREE.Mesh( geometry, meshMaterialArray );
                                if (shadowFlag) {
                                    mesh.castShadow  = true;
                                    mesh.receiveShadow   = true;
                                } else {
                                    mesh.castShadow  = false;
                                    mesh.receiveShadow   = false;
                                }
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_piece].mesh=mesh;
                                updateDesign.pieces[i].array[array_piece].mesh.b = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.h = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.d = 0.5;
                                updateDesign.pieces[i].array[array_piece].mesh.lz = 1.;
                                node.add( mesh );
                            }
                            updatePosition(updateDesign, i, array_piece);
// Extrude or Revolution
                        } else if (updateDesign.pieces[i].type == 'Extrude' ||
                                   updateDesign.pieces[i].type == 'Revolution') {
                            if (!isMesh(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create Extrude/Revolution geometry");
                                
                                var geometry;
                                if (updateDesign.pieces[i].type == 'Extrude') {
                                    const shape = new THREE.Shape();
                                    shape.moveTo( 0,0 );
                                    shape.lineTo( 0, 1 );
                                    shape.lineTo( 1, 0.5 );
                                    shape.lineTo( 0, 0 );
                                    const extrudeSettings = {
                                        bevelEnabled: false
                                    };
                                    geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
                                    meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 2);
                                } else if (updateDesign.pieces[i].type == 'Revolution') {
                                    const shape = [];
                                    shape.push( new THREE.Vector2(0,0));
                                    shape.push( new THREE.Vector2(0, 1));
                                    shape.push( new THREE.Vector2(1, 0.5));
                                    shape.push( new THREE.Vector2(0, 0));
                                    geometry = new THREE.LatheGeometry( shape, 32 );
                                    meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 1);
                                }

                                mesh = new THREE.Mesh( geometry, meshMaterialArray );
                                if (shadowFlag) {
                                    mesh.castShadow  = true;
                                    mesh.receiveShadow   = true;
                                } else {
                                    mesh.castShadow  = false;
                                    mesh.receiveShadow   = false;
                                }
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_piece].mesh=mesh;
                                //updateDesign.pieces[i].array[array_piece].mesh.b = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.shape_array = [];
                                shape_array = updateDesign.pieces[i].shape_array;
                                for (var k =0; k< shape_array.length; k++) {
                                    updateDesign.pieces[i].array[array_piece].mesh.shape_array[k] = [];
                                    updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][0] = 0;
                                    updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][1] = 0;
                                }

                                updateDesign.pieces[i].array[array_piece].mesh.lz = 0.076;  // random number, only for extrude
                                node.add( mesh );
                            }
                            updatePosition(updateDesign, i, array_piece);
// Box
                        } else if (updateDesign.pieces[i].type == 'Box') {
                            if (updateDesign.pieces[i].type != 'Box') {
                                console.warn("type not defined for piece :" + i + " type: " + updateDesign.pieces[i].type);
                                updateDesign.pieces[i].type = "Box";
                            }
                            if (!isMesh(updateDesign.pieces[i].array[array_piece].mesh)) {
                                if (console_flag) console.log("Create mesh geometry");
                                geometry = new THREE.BoxGeometry( 1., 1., 1. );

                                geometry.translate( 0.5, 0.5, 0.5 ) ;
                                meshMaterialArray = createMaterialArray(updateDesign.pieces[i], 6);
                                mesh = new THREE.Mesh( geometry, meshMaterialArray );
                                if (shadowFlag) {
                                    mesh.castShadow  = true;
                                    mesh.receiveShadow   = true;
                                } else {
                                    mesh.castShadow  = false;
                                    mesh.receiveShadow   = false;
                                }
                                mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                
                                updateDesign.pieces[i].array[array_piece].mesh=mesh;
                                updateDesign.pieces[i].array[array_piece].mesh.lx = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.ly = 1.;
                                updateDesign.pieces[i].array[array_piece].mesh.lz = 1.;
                                node.add( mesh );
                            }
                            updatePosition(updateDesign, i, array_piece);
// PointLight
                        } else if (updateDesign.pieces[i].type == 'Point') {
                            if (!isType(updateDesign.pieces[i].array[array_piece].light, "PointLight")) {
                                if (console_flag) console.log("Create PointLight");
                                const light = new THREE.PointLight( 0xffffff, 1.0, 10, 2 );
                                createdLights = true;
                                const helperLight = new THREE.PointLightHelper( light, 0.5 );
                                lightHelperGroup.add( helperLight);
                                if (shadowFlag) {
                                    light.castShadow = true;
                                } else {
                                    light.castShadow = false;
                                }
//                                const helper = new THREE.PointLightHelper( light, 5 );
//                                node.add( helper );

                                light.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation

                                updateDesign.pieces[i].array[array_piece].light=light;
                                updateDesign.pieces[i].array[array_piece].light.intensity = 0.67;
                                updateDesign.pieces[i].array[array_piece].light.distance = 0.67;
                                updateDesign.pieces[i].array[array_piece].light.decay = 0.67;
                                node.add( light );
                            }
// DirectionalLight
                        } else if (updateDesign.pieces[i].type == 'Directional') {
                            if (!isType(updateDesign.pieces[i].array[array_piece].light, "DirectionalLight")) {
                                if (console_flag) console.log("Create DirectionalLight");
                                const light = new THREE.DirectionalLight( 0xffffff, 1.0);
                                //light.shadow.camera.near = 50;
                                //light.shadow.camera.far = 150;
                                light.target.position.set(0, 0, 0);
                                scene.add(light.target);
                                scene.add(light);
                                createdLights = true;
                                const helperLight = new THREE.DirectionalLightHelper( light, 0.5 );
                                lightHelperGroup.add( helperLight);
                                light.helper = helperLight

                                if (shadowFlag) {
                                    light.castShadow = true;
                                } else {
                                    light.castShadow = false;
                                }

                                light.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation

                                updateDesign.pieces[i].array[array_piece].light=light;
                                updateDesign.pieces[i].array[array_piece].light.intensity = 0.67;
                                node.add( light );
                            }
                        } else {
                            console.warn("type not found for piece :" + i + " type: " + updateDesign.pieces[i].type);
                        }
                        
                        // Set default values if non exist
                        setDefaultValues(updateDesign.pieces[i]);
                        
                        // For meshes
                        if (updateDesign.pieces[i].array[array_piece].mesh != undefined) {
                            updateMeshPosition(updateDesign, i, array_piece);
                            if (updateDesign.pieces[i].array[array_piece].meshCsgModified != null) {
                                updateDesign.pieces[i].array[array_piece].mesh.visible = false;
                            } else {
                                updateDesign.pieces[i].array[array_piece].mesh.visible = true;
                            }
                            
                            // Material check
                            // compare if material_1 has changed (by user input or edit in pieces
                            // get name of material 1
                            var piece = updateDesign.pieces[i];
                            
                            // control of change of material and mesh
                            var piece_materialChange = false;
                            var meshRecreated = false;
                            
                            if (piece.material_1 != null) {
                                var materialName = getMaterialArrayName(piece, updateDesign.pieces[i].array[array_piece].mesh.material);
                                if (console_flag) console.log("materialName: " + materialName);

                                if (    updateDesign.pieces[i].array[array_piece].mesh.material != null && 
                                        updateDesign.pieces[i].array[array_piece].mesh.material.previousName != materialName &&
                                        !(updateDesign.pieces[i].array[array_piece].mesh.setUV)) {
                                    if (console_flag) console.log("change of material: " + materialName);
                                    piece_materialChange = true;
                                    var arrayLength;
                                    if  (!Array.isArray(updateDesign.pieces[i].array[array_piece].mesh.material)) {
                                        arrayLength = 1;
                                    } else {
                                        arrayLength = updateDesign.pieces[i].array[array_piece].mesh.material.length;
                                    }
                                    meshMaterialArray = createMaterialArray(updateDesign.pieces[i], arrayLength);
                                    updateDesign.pieces[i].array[array_piece].mesh.material = meshMaterialArray;
                                }
                            }

                            // Box
                            if (updateDesign.pieces[i].array[array_piece].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Box") {  // geometry.type == "BoxGeometry" We compare with pieces.type because different types can share same geometry.type

                                lx = eval(updateDesign.pieces[i].lx);
                                ly = eval(updateDesign.pieces[i].ly);
                                lz = eval(updateDesign.pieces[i].lz);
                                if (lx == null) lx = parameterDefaults.Box.lx;
                                if (ly == null) ly = parameterDefaults.Box.ly;
                                if (lz == null) lz = parameterDefaults.Box.lz;
                                if (updateDesign.pieces[i].array[array_piece].mesh.lx != lx ||
                                    updateDesign.pieces[i].array[array_piece].mesh.ly != ly ||
                                    updateDesign.pieces[i].array[array_piece].mesh.lz != lz ||
                                    updateDesign.pieces[i].array[array_piece].meshPositionChange == true) {  // only create if theres is a change

                                    updateDesign.pieces[i].array[array_piece].mesh.lx = lx;
                                    updateDesign.pieces[i].array[array_piece].mesh.ly = ly;
                                    updateDesign.pieces[i].array[array_piece].mesh.lz = lz;

                                    updateDesign.pieces[i].array[array_piece].mesh.geometry.dispose();
                                    updateDesign.pieces[i].array[array_piece].mesh.geometry =  new THREE.BoxGeometry(lx, ly, lz); 
                                    updateDesign.pieces[i].array[array_piece].meshCsgModified = null;
                                    updateDesign.pieces[i].array[array_piece].mesh.geometry.translate(lx/2, ly/2, lz/2);
                                    meshRecreated = true;
                                    
                                    booleanOperation(updateDesign, i, array_piece) ;
                                    
                                }
                                
                                if (piece_materialChange || meshRecreated) {
                                    //scale texture
                                    //we change the uv coordinates of the geometry, so the same texture can be applied to different faces and different pieces
                                    //Float32Array(48) [0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,
                                    //                 000102030405060708091011121314151617181920212223242526272829303132333435363738394041424344454647
                                    uva= updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").array;
                                    // face 1 (X=1) (1,1,1) 0, 1, 1, 1, 0, 0, 1, 0,
                                    //Face 1
                                    var ini = 0;
                                    if (updateDesign.pieces[i].material_1_Perpendicular == 1) {
                                    // u=1, v=2 [2, 0, 2, -1, 0, 0, 0, -1]  2=ly; 1 =lz
                                        uva[ini + 0] = ly;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = ly;
                                        uva[ini + 3] = -lz;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lz;
                                    } else {
                                    // u=1, v=2 [0, 2, 1, 2, 0, 0, 1, 0,
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = ly;
                                        uva[ini + 2] = lz;
                                        uva[ini + 3] = ly;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lz;
                                        uva[ini + 7] = 0;
                                    }
                                    //Face 2
                                    var ini = ini + 8;
                                    if (updateDesign.pieces[i].material_2_Perpendicular == 1) {
                                        uva[ini + 0] = ly;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = ly;
                                        uva[ini + 3] = -lz;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lz;
                                    } else {
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = ly;
                                        uva[ini + 2] = lz;
                                        uva[ini + 3] = ly;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lz;
                                        uva[ini + 7] = 0;
                                    }
                                    //Face 3
                                    var ini = ini + 8;
                                    if (updateDesign.pieces[i].material_3_Perpendicular == 1) {
                                        uva[ini + 0] = lz;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = lz;
                                        uva[ini + 3] = -lx;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lx;
                                    } else {
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = lz;
                                        uva[ini + 2] = lx;
                                        uva[ini + 3] = lz;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lx;
                                        uva[ini + 7] = 0;
                                    }
                                    //Face 4
                                    var ini = ini + 8;
                                    if (updateDesign.pieces[i].material_4_Perpendicular == 1) {
                                        uva[ini + 0] = lz;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = lz;
                                        uva[ini + 3] = -lx;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lx;
                                    } else {
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = lz;
                                        uva[ini + 2] = lx;
                                        uva[ini + 3] = lz;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lx;
                                        uva[ini + 7] = 0;
                                    }
                                    //Face 5
                                    var ini = ini + 8;
                                    if (updateDesign.pieces[i].material_5_Perpendicular == 1) {
                                        uva[ini + 0] = ly;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = ly;
                                        uva[ini + 3] = -lx;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lx;
                                    } else {
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = ly;
                                        uva[ini + 2] = lx;
                                        uva[ini + 3] = ly;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lx;
                                        uva[ini + 7] = 0;
                                    }
                                    //Face 6
                                    var ini = ini + 8;
                                    if (updateDesign.pieces[i].material_6_Perpendicular == 1) {
                                        uva[ini + 0] = ly;
                                        uva[ini + 1] = 0;
                                        uva[ini + 2] = ly;
                                        uva[ini + 3] = -lx;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = 0;
                                        uva[ini + 7] = -lx;
                                    } else {
                                        uva[ini + 0] = 0;
                                        uva[ini + 1] = ly;
                                        uva[ini + 2] = lx;
                                        uva[ini + 3] = ly;
                                        uva[ini + 4] = 0;
                                        uva[ini + 5] = 0;
                                        uva[ini + 6] = lx;
                                        uva[ini + 7] = 0;
                                    }
                                    updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                }
                                    
                            }
                                   
                            // Cylinder
                            if (updateDesign.pieces[i].array[array_piece].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Cylinder") {  // geometry.type == "CylinderGeometry"
                                    rt = eval(updateDesign.pieces[i].rt);
                                    rb = eval(updateDesign.pieces[i].rb);
                                    lz = eval(updateDesign.pieces[i].lz);
                                    if (rt == null) rt = parameterDefaults.Cylinder.rt;
                                    if (rb == null) rb = parameterDefaults.Cylinder.rb;
                                    if (lz == null) lz = parameterDefaults.Cylinder.lz;


                                    if (updateDesign.pieces[i].array[array_piece].mesh.rt != rt ||
                                        updateDesign.pieces[i].array[array_piece].mesh.rb != rb ||
                                        updateDesign.pieces[i].array[array_piece].mesh.lz != lz ||
                                        piece_materialChange ||  // in the Cylinder we must create it when Perpendicular property change, because uv must be updated
                                        updateDesign.pieces[i].array[array_piece].meshPositionChange == true) {  // only create if theres is a change

                                        updateDesign.pieces[i].array[array_piece].mesh.rt = rt;
                                        updateDesign.pieces[i].array[array_piece].mesh.rb = rb;
                                        updateDesign.pieces[i].array[array_piece].mesh.lz = lz;

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.dispose();
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry =  new THREE.CylinderGeometry(rt, rb, lz, 32); 
                                        updateDesign.pieces[i].array[array_piece].meshCsgModified = null;
                                        //updateDesign.pieces[i].array[array_piece].mesh.geometry.translate(rt/2, rb/2, lz/2);
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.translate(0, lz/2, 0);
                                        //updateDesign.pieces[i].array[array_piece].mesh.rotation.x = Math.PI/2;
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.rotateX(Math.PI/2);
//                                      meshRecreated = true;
//                                  }
//                                  if (piece_materialChange || meshRecreated) {

                                        //scale texture
                                        //we change the uv coordinates of the geometry, so the same texture can be applied to different faces and different pieces
                                        //Float32Array(392) [0, 1, 0.03125, 1, ... 
                                        uva= updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").array;
                                        
                                        /*
                                        33     lateral v = 1
                                        33  66 lateral v = 0
                                        32 132 centro top
                                        33 196 circulo
                                        32 262 centro botttom
                                        33 326 circulo
                                           392
                                        */
                                        if (updateDesign.pieces[i].material_1_Perpendicular == 1) {
                                            r2 = (rt + rb) / 2.0
                                            // top rt
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                u_prev = uva[iuv + 0]
                                                v_prev = uva[iuv + 1]
                                                uva[iuv]     = v_prev * lz;
                                                uva[iuv + 1] = u_prev * (-1) * r2 * 2 * Math.PI;
                                            }
                                            // bottom rb
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                u_prev = uva[66 + iuv + 0]
                                                v_prev = uva[66 + iuv + 1]
                                                uva[66 + iuv] = 0; //*= lz;  // os 0
                                                uva[66 + iuv + 1] = u_prev * (-1) * r2 * 2 * Math.PI;
                                            }
                                        } else {
                                            r2 = (rt + rb) / 2.0
                                            // top rt
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                uva[iuv]     *= r2 * 2 * Math.PI;
                                                uva[iuv + 1] *= lz;
                                            }
                                            // bottom rb
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                uva[66 + iuv]     *= r2 * 2 * Math.PI;
                                                uva[66 + iuv + 1] = 0; //*= lz;  // os 0
                                            }
                                        }
                                        // circle top
                                        if (updateDesign.pieces[i].material_2_Perpendicular == 1) {
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                u_prev = uva[196 + iuv + 0]
                                                v_prev = uva[196 + iuv + 1]
                                                uva[196 + iuv]     = (v_prev-0.5)*rt*2+0.5;
                                                uva[196 + iuv + 1] = -(u_prev-0.5)*rt*2+0.5;  // os 0
                                            }
                                        } else {
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                uva[196 + iuv]     = (uva[196 + iuv]-0.5)*rt*2+0.5;
                                                uva[196 + iuv + 1] = (uva[196 + iuv + 1]-0.5)*rt*2+0.5;  // os 0
                                            }
                                        }
                                        // circle bottom
                                        if (updateDesign.pieces[i].material_3_Perpendicular == 1) {
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                u_prev = uva[326 + iuv + 0]
                                                v_prev = uva[326 + iuv + 1]
                                                uva[326 + iuv]     = (v_prev-0.5)*rb*2+0.5;
                                                uva[326 + iuv + 1] = -(u_prev-0.5)*rb*2+0.5;  // os 0
                                            }
                                        } else {
                                            for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                                uva[326 + iuv]     = (uva[326 + iuv]-0.5)*rb*2+0.5;
                                                uva[326 + iuv + 1] = (uva[326 + iuv + 1]-0.5)*rb*2+0.5;  // os 0
                                            }
                                        }

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                        
                                        booleanOperation(updateDesign, i, array_piece) ;
                                    }
                            }
                            // Sphere
                            if (updateDesign.pieces[i].array[array_piece].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Sphere") {  // geometry.type == "SphereGeometry"  check
                                    r = eval(updateDesign.pieces[i].r);
                                    if (r == null) r = parameterDefaults.Sphere.r;

                                    if (updateDesign.pieces[i].array[array_piece].mesh.r != r ||
                                        updateDesign.pieces[i].array[array_piece].meshPositionChange == true) {  // only create if theres is a change

                                        updateDesign.pieces[i].array[array_piece].mesh.r = r;

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.dispose();
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry =  new THREE.SphereGeometry(r, 32, 32);
                                        updateDesign.pieces[i].array[array_piece].meshCsgModified = null;
                                        
                                        booleanOperation(updateDesign, i, array_piece) ;

                                        //updateDesign.pieces[i].array[array_piece].mesh.geometry.translate(rt/2, rb/2, lz/2);

                                        //scale texture
                                        //we change the uv coordinates of the geometry, so the same texture can be applied to different faces and different pieces
                                        //Float32Array(392) [0, 1, 0.03125, 1, ... 
                                        uva= updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").array;
                                        
                                        // Pending change uv of Sphere
                                        /*
                                        33     lateral v = 1
                                        33  66 lateral v = 0
                                        32 132 centro top
                                        33 196 circulo
                                        32 262 centro botttom
                                        33 326 circulo
                                           392
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[iuv]     *= rt * 2 * Math.PI;
                                            uva[iuv + 1] *= lz;
                                        }
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[66 + iuv]     *= rb * 2 * Math.PI;
                                            //uva[66 + iuv + 1] *= lz;  // os 0
                                        }
                                        // circle top
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[196 + iuv]     = (uva[196 + iuv]-0.5)*rt*2+0.5;
                                            uva[196 + iuv + 1] = (uva[196 + iuv + 1]-0.5)*rt*2+0.5;  // os 0
                                        }
                                        // circle bottom
                                        for (var iuv =0; iuv< 65; iuv = iuv + 2) {
                                            uva[326 + iuv]     = (uva[326 + iuv]-0.5)*rb*2+0.5;
                                            uva[326 + iuv + 1] = (uva[326 + iuv + 1]-0.5)*rb*2+0.5;  // os 0
                                        }
                                        */

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                    }
                            }
                            // Triangle
                            if (updateDesign.pieces[i].array[array_piece].mesh.geometry != null &&
                                updateDesign.pieces[i].type == "Triangle") {  // geometry.type == "ExtrudeGeometry"
                                    b = eval(updateDesign.pieces[i].b);
                                    h = eval(updateDesign.pieces[i].h);
                                    d = eval(updateDesign.pieces[i].d);
                                    lz = eval(updateDesign.pieces[i].lz);

                                    if (updateDesign.pieces[i].array[array_piece].mesh.b != b ||
                                        updateDesign.pieces[i].array[array_piece].mesh.h != h ||
                                        updateDesign.pieces[i].array[array_piece].mesh.d != d ||
                                        updateDesign.pieces[i].array[array_piece].mesh.lz != lz ||
                                        updateDesign.pieces[i].array[array_piece].meshPositionChange == true) {  // only create if theres is a change
                                        
                                        updateDesign.pieces[i].array[array_piece].mesh.b = b;
                                        updateDesign.pieces[i].array[array_piece].mesh.h = h;
                                        updateDesign.pieces[i].array[array_piece].mesh.d = d;
                                        updateDesign.pieces[i].array[array_piece].mesh.lz = lz;

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.dispose();
                                        const shape = new THREE.Shape();
                                        shape.moveTo( 0,0 );
                                        shape.lineTo( b, 0);   
                                        shape.lineTo( d, h );
                                        //shape.lineTo( 0, 0 );

                                        const extrudeSettings = {
                                            steps: 1,
                                            depth: lz,
                                            bevelEnabled: false
                                        };

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
                                        updateDesign.pieces[i].array[array_piece].meshCsgModified = null;

                                        //mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                        //mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                        
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                        
                                        booleanOperation(updateDesign, i, array_piece) ;
                                    }
                            }
                            // Extrude or Revolution
                            if (updateDesign.pieces[i].array[array_piece].mesh.geometry != null &&
                               (updateDesign.pieces[i].type == "Extrude" || 
                                updateDesign.pieces[i].type == 'Revolution')) {  // geometry.type == "ExtrudeGeometry"
                                    //b = eval(updateDesign.pieces[i].b);
                                    shape_array = updateDesign.pieces[i].shape_array;
                                    lz = eval(updateDesign.pieces[i].lz);

                                    var changeArray = false;
                                    for (var k =0; k< shape_array.length; k++) {
                                        for (var k_row =0; k_row< shape_array[k].length; k_row++) {
                                            if (updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][k_row] != 
                                               eval(shape_array[k][k_row])) changeArray = true;
                                            //if (updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][1] != 
                                            //   eval(shape_array[k][1])) changeArray = true;
                                        }
                                    }
                                    if (//updateDesign.pieces[i].array[array_piece].mesh.b != b ||
                                        shape_array != null && 
                                        (updateDesign.pieces[i].array[array_piece].mesh.lz != lz ||
                                        changeArray ||
                                        piece_materialChange ||  // for texture Perpendicular change
                                        updateDesign.pieces[i].array[array_piece].meshPositionChange == true)) {  // only create if theres is a change

                                        //updateDesign.pieces[i].array[array_piece].mesh.b = b;
                                        updateDesign.pieces[i].array[array_piece].mesh.lz = lz;
                                        for (var k =0; k< shape_array.length; k++) {
                                            updateDesign.pieces[i].array[array_piece].mesh.shape_array[k] = [];
                                            updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][0] = 
                                               eval(shape_array[k][0]);
                                            updateDesign.pieces[i].array[array_piece].mesh.shape_array[k][1] = 
                                               eval(shape_array[k][1]);
                                        }

                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.dispose();


                                        if (updateDesign.pieces[i].type == "Extrude") {
                                            const shape = new THREE.Shape();
                                            shape.moveTo( eval(shape_array[0][0]), eval(shape_array[0][1]));
                                            for (var k =1; k< shape_array.length; k++) {
                                                if (shape_array[k].length == 2) {
                                                    shape.lineTo( eval(shape_array[k][0]), eval(shape_array[k][1]));   
                                                } else {
                                                    shape.bezierCurveTo(
                                                        eval(shape_array[k][2]), eval(shape_array[k][3]),
                                                        eval(shape_array[k][4]), eval(shape_array[k][5]),
                                                        eval(shape_array[k][0]), eval(shape_array[k][1])
                                                    )
                                                }
                                            }
                                            //shape.lineTo( eval(shape_array[0][0]), eval(shape_array[0][1]));
                                            const extrudeSettings = {
                                                steps: 1,
                                                depth: lz,
                                                bevelEnabled: false
                                            };
                                            updateDesign.pieces[i].array[array_piece].mesh.geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
                                            updateDesign.pieces[i].array[array_piece].meshCsgModified = null;
                                            
                                            // texture Perpendicular
                                            uva= updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").array;
                                            // n_points: 
                                            // there are n_poins - 2 triangles in top and in base
                                            // there are n_points * 2 triangles in lateral
                                            // total triangles: (n-2)*2 + n*2 = 2n - 4 + 2n = 4n - 4
                                            // total vertex uv: (4n -4) * 3 = 12n-12 => n = (uva.length + 12) / 12 = uva.length/12 + 1
                                            // Vertex in Top and base (Material_1 ): (n_points - 2) * 2 * 3 (2 coordinates u and v each one) 
                                            // Vertex in lateral      (Material_2 ): n_points * 2 * 3 (2 coordinates u and v each one) 
                                            n_points = ((uva.length/2) / 12) +1;
                                            if (updateDesign.pieces[i].material_1_Perpendicular == 1) {
                                            // top rt
                                                for (var iuv =0; iuv< (n_points - 2) * 2 * 3 * 2; iuv = iuv + 2) {
                                                    u_prev = uva[iuv + 0]
                                                    v_prev = uva[iuv + 1]
                                                    uva[iuv]     = v_prev;
                                                    uva[iuv + 1] = -u_prev;
                                                }
                                            }
                                            if (updateDesign.pieces[i].material_2_Perpendicular == 1) {
                                            // top rt
                                                for (var iuv =(n_points - 2) * 2 * 3 * 2; iuv< uva.length; iuv = iuv + 2) {
                                                    u_prev = uva[iuv + 0]
                                                    v_prev = uva[iuv + 1]
                                                    uva[iuv]     = v_prev;
                                                    uva[iuv + 1] = -u_prev;
                                                }
                                            }
                                            updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                            // end of texture Perpendicular
                                            
                                        } else if (updateDesign.pieces[i].type == "Revolution") {
                                            const shape = [];
                                            for (var k =0; k< shape_array.length; k++) {
                                                shape.push( new THREE.Vector2(eval(shape_array[k][0]), eval(shape_array[k][1]) ));    
                                            }
                                            updateDesign.pieces[i].array[array_piece].mesh.geometry = new THREE.LatheGeometry( shape, 32 );
                                        }

                                        //mesh = new THREE.Mesh( geometry, getMaterial(updateDesign.pieces[i].material).material );
                                        //mesh.rotation.order='ZYX'  // so first define X rotation, after Y rotation and last Z rotation
                                        
                                        updateDesign.pieces[i].array[array_piece].mesh.geometry.getAttribute("uv").needsUpdate = true;
                                        
                                        booleanOperation(updateDesign, i, array_piece) ;
                                    }
                            }

                            // moved to previous of mesh change
                            //updateMeshPosition(updateDesign, i, array_piece);
                            
/*
                            updateDesign.pieces[i].array[array_piece].mesh.position.x = 
                                   Number(eval(updateDesign.pieces[i].x));
                            updateDesign.pieces[i].array[array_piece].mesh.position.y = 
                                   Number(eval(updateDesign.pieces[i].y));
                            updateDesign.pieces[i].array[array_piece].mesh.position.z = 
                                   Number(eval(updateDesign.pieces[i].z));                            
*/
                        }
                        
                        // For lights
                        if (updateDesign.pieces[i].array[array_piece].light != undefined) {
                            // Light Sphere
                            if (isType(updateDesign.pieces[i].array[array_piece].light, "PointLight")) {
                                intensity = eval(updateDesign.pieces[i].intensity);
                                distance  = eval(updateDesign.pieces[i].distance);
                                decay    = eval(updateDesign.pieces[i].decay);
                                if (intensity == null) intensity = 0;
                                if (distance == null)  distance = 0;
                                if (decay == null)     decay = 1;  // default value of decay

                                if (updateDesign.pieces[i].array[array_piece].light.intensity != intensity ||
                                    updateDesign.pieces[i].array[array_piece].light.distance  != distance  ||
                                    updateDesign.pieces[i].array[array_piece].light.decay     != decay) {  // only create if theres is a change

                                    updateDesign.pieces[i].array[array_piece].light.intensity = intensity;
                                    updateDesign.pieces[i].array[array_piece].light.distance = distance;
                                    updateDesign.pieces[i].array[array_piece].light.decay = decay;

                                    //updateDesign.pieces[i].array[array_piece].light.dispose();
                                    //updateDesign.pieces[i].array[array_piece].light = new THREE.PointLight( 0xffffff, intensity, distance, decay);
                                    updateDesign.pieces[i].array[array_piece].light.intensity = intensity;
                                    updateDesign.pieces[i].array[array_piece].light.distance = distance;
                                    updateDesign.pieces[i].array[array_piece].light.decay = decay;
                                }
                            } else if (isType(updateDesign.pieces[i].array[array_piece].light, "DirectionalLight")) {
                                intensity = eval(updateDesign.pieces[i].intensity);
                                if (intensity == null) intensity = 0.1;

                                if (updateDesign.pieces[i].array[array_piece].light.intensity != intensity) {  // only create if theres is a change

                                    updateDesign.pieces[i].array[array_piece].light.intensity = intensity;

                                    //updateDesign.pieces[i].array[array_piece].light.dispose();
                                    //updateDesign.pieces[i].array[array_piece].light = new THREE.PointLight( 0xffffff, intensity, distance, decay);
                                    updateDesign.pieces[i].array[array_piece].light.intensity = intensity;
                                }
                            }
                            // Position
                            updateDesign.pieces[i].array[array_piece].light.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));
                            if (isType(updateDesign.pieces[i].array[array_piece].light, "DirectionalLight")) {
                                updateDesign.pieces[i].array[array_piece].light.target.updateMatrixWorld();
                                updateDesign.pieces[i].array[array_piece].light.helper.update();
                            }
                        }
                            
                    }
                }
                if (light1 != null) {
                    if (light1.intensity != settings.pointLightFactor)
                        light1.intensity  = settings.pointLightFactor;
                    if (light2.intensity != settings.pointLightFactor)
                        light2.intensity  = settings.pointLightFactor;
                    if (light3.intensity != settings.directionalLightFactor)
                        light3.intensity  = settings.directionalLightFactor;
                    if (light4.intensity != settings.directionalLightFactor)
                        light4.intensity  = settings.directionalLightFactor;
                    if (hemiLightObject.intensity != settings.hemiLightFactor)
                        hemiLightObject.intensity  = settings.hemiLightFactor;
                }
            }

            function updatePosition(updateDesign, i, array_piece) {
                // to be eliminated when updateMeshPosition works correctly 
                    pos_x = Number(eval(updateDesign.pieces[i].x));
                    pos_y = Number(eval(updateDesign.pieces[i].y));
                    pos_z = Number(eval(updateDesign.pieces[i].z));
                    if (pos_x == null) pos_x = 0;
                    if (pos_y == null) pos_y = 0;
                    if (pos_z == null) pos_z = 0;
                                /*
                                updateDesign.pieces[i].array[array_piece].mesh.position.set(
                                   Number(eval(updateDesign.pieces[i].x)),
                                   Number(eval(updateDesign.pieces[i].y)), 
                                   Number(eval(updateDesign.pieces[i].z)));
                                */
                    updateDesign.pieces[i].array[array_piece].mesh.position.set( pos_x, pos_y, pos_z);
            }
            function updateMeshPosition(updateDesign, i, array_piece) {
                eval(updateDesign.pieces[i].array[array_piece].evalText);
                if (updateDesign.pieces[i].array[array_piece].mesh.x != Number(eval(updateDesign.pieces[i].x)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.y != Number(eval(updateDesign.pieces[i].y)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.z != Number(eval(updateDesign.pieces[i].z)) ||
                    
                    updateDesign.pieces[i].array[array_piece].mesh.sx != Number(eval(updateDesign.pieces[i].sx)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.sy != Number(eval(updateDesign.pieces[i].sy)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.sz != Number(eval(updateDesign.pieces[i].sz)) ||
                    
                    updateDesign.pieces[i].array[array_piece].mesh.rx != Number(eval(updateDesign.pieces[i].rx)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.ry != Number(eval(updateDesign.pieces[i].ry)) ||
                    updateDesign.pieces[i].array[array_piece].mesh.rz != Number(eval(updateDesign.pieces[i].rz))  ) { // only if theres is a change

                        updateDesign.pieces[i].array[array_piece].meshPositionChange = true;
                        
                        updateDesign.pieces[i].array[array_piece].mesh.x = Number(eval(updateDesign.pieces[i].x));
                        updateDesign.pieces[i].array[array_piece].mesh.y = Number(eval(updateDesign.pieces[i].y));
                        updateDesign.pieces[i].array[array_piece].mesh.z = Number(eval(updateDesign.pieces[i].z));

                        updateDesign.pieces[i].array[array_piece].mesh.sx = Number(eval(updateDesign.pieces[i].sx));
                        updateDesign.pieces[i].array[array_piece].mesh.sy = Number(eval(updateDesign.pieces[i].sy));
                        updateDesign.pieces[i].array[array_piece].mesh.sz = Number(eval(updateDesign.pieces[i].sz));

                        updateDesign.pieces[i].array[array_piece].mesh.rx = Number(eval(updateDesign.pieces[i].rx));
                        updateDesign.pieces[i].array[array_piece].mesh.ry = Number(eval(updateDesign.pieces[i].ry));
                        updateDesign.pieces[i].array[array_piece].mesh.rz = Number(eval(updateDesign.pieces[i].rz));

                        // Position
                        updateDesign.pieces[i].array[array_piece].mesh.position.set(
                               Number(eval(updateDesign.pieces[i].x)),
                               Number(eval(updateDesign.pieces[i].y)), 
                               Number(eval(updateDesign.pieces[i].z)));

                        updateDesign.pieces[i].array[array_piece].mesh.scale.set(
                            eval(updateDesign.pieces[i].sx), 
                            eval(updateDesign.pieces[i].sy), 
                            eval(updateDesign.pieces[i].sz));

                            updateDesign.pieces[i].array[array_piece].mesh.rotation.z = 
                                eval(updateDesign.pieces[i].rz) * Math.PI / 180.;
                            updateDesign.pieces[i].array[array_piece].mesh.rotation.y = 
                                eval(updateDesign.pieces[i].ry) * Math.PI / 180.;
                            updateDesign.pieces[i].array[array_piece].mesh.rotation.x = 
                                eval(updateDesign.pieces[i].rx) * Math.PI / 180.;

                        //booleanOperation(updateDesign, i, array_piece) ;
                }
            }

            function booleanOperation(updateDesign, i, array_piece) {
                //operation (intersect, subtract
                if (updateDesign.pieces[i].operation != null &&
                   (updateDesign.pieces[i].operation == "subtract" || 
                    updateDesign.pieces[i].operation == "union" || 
                    updateDesign.pieces[i].operation == "intersect")) {
                    var i_lastPieceToCSG = getLastMesh(updateDesign, i, array_piece);
                    if (i_lastPieceToCSG >= 0) {
                        //var meshA = updateDesign.pieces[i - 1].array[array_piece].mesh;
                        var lastPieceToCSG = updateDesign.pieces[i_lastPieceToCSG];
                        var meshA;
                            meshA = lastPieceToCSG.array[array_piece].mesh;
                        /*
                        if (lastPieceToCSG.array[array_piece].meshCsgModified != null) {
                            meshA = lastPieceToCSG.array[array_piece].meshCsgModified;
                        } else {
                            meshA = lastPieceToCSG.array[array_piece].mesh;
                        }
                        */
                        var meshB = updateDesign.pieces[i].array[array_piece].mesh;
                        meshA.updateMatrix()
                        meshB.updateMatrix()
                        
                        // check if meshA.material is an array of materials and get first element or is a material
                        if (Array.isArray(meshA.material)) {
                            materialA = meshA.material[0];
                        } else {
                            materialA = meshA.material;
                        }
                         //Create a bsp tree from each of the meshes
                        let bspA = CSG.fromMesh( meshA )                        
                        let bspB = CSG.fromMesh( meshB )

                        // Subtract one bsp from the other via .subtract... other supported modes are .union and .intersect
                        let bspResult;
                        if (updateDesign.pieces[i].operation == "subtract") {
                            bspResult = bspA.subtract(bspB);
                        } else if (updateDesign.pieces[i].operation == "intersect") {
                            bspResult = bspA.intersect(bspB);
                        } else if (updateDesign.pieces[i].operation == "union") {
                            bspResult = bspA.union(bspB);
                        }

                        
                        //Get the resulting mesh from the result bsp, and assign meshA.material to the resulting mesh
                        //var subtractMaterial = new THREE.MeshStandardMaterial({color:'blue',roughness:1,metalness:0.8})
                        let meshResult = CSG.toMesh( bspResult, meshA.matrix, materialA)
                        if (lastPieceToCSG.array[array_piece].meshCsgModified != null) {
                            meshCsgModified = lastPieceToCSG.array[array_piece].meshCsgModified;
                            meshCsgModified.parent.remove(meshCsgModified);
                        }
                        lastPieceToCSG.array[array_piece].meshCsgModified = meshResult; 
                        lastPieceToCSG.array[array_piece].mesh.parent.add(meshResult);
                        //meshA.parent.remove(meshA);
                        //meshB.parent.remove(meshB);
                    }
                }
                //end operation
            }
                                
            function getLastMesh(updateDesign, array_pos, array_piece) {
                for (var i = array_pos - 1; i >= 0; i--) {
                    if (isMesh(updateDesign.pieces[i].array[array_piece].mesh) &&
                        updateDesign.pieces[i].operation == null ) {
                        return i;
                    }
                }
            }
            function getMaterialArrayName(piece, meshMaterialArray) {
                var materialProperties = ["","material_1","material_2","material_3","material_4","material_5","material_6"];
                var materialArrayName = "";
                if (piece.material_1 == null) {
                    materialArrayName = materialArr[0].name;
                } else {
                    if (piece.material_1.startsWith("parameter:")) {
                        materialArrayName = eval(piece.material_1.substring(10));  // remove "parameter:" String from value
                    } else {
                        materialArrayName = piece.material_1;
                    }
                    if (piece.material_1_Perpendicular != null) {
                        materialArrayName += "-" + piece.material_1_Perpendicular;
                    }
                }
                if  (Array.isArray(meshMaterialArray)) {
                    for (i = 2; i <= meshMaterialArray.length; i++) {
                        if (piece[materialProperties[i]] == null) {
                            material_i = "";
                        } else if (piece[materialProperties[i]].startsWith("parameter:")) {
                            material_i = eval(piece[materialProperties[i]].substring(10));  // remove "parameter:" String from value
                        } else {
                            material_i = piece[materialProperties[i]];
                        }
                        materialArrayName += "-" + material_i;
                        if (piece[materialProperties[i] + "_Perpendicular"] != null) {
                            materialArrayName += "-" + piece[materialProperties[i] + "_Perpendicular"];
                        }
                    }
                }
                return materialArrayName;
            }

            function getPieceMaterialParameter(piece, materialProperty) {
                var material;
                if (piece["material_" + materialProperty] == null) {
                    return null;
                }
                if (piece["material_" + materialProperty].startsWith("parameter:")) {
                    material = eval(piece["material_" + materialProperty].substring(10));  // remove "parameter:" String from value
                    if (console_flag) console.log("material_" + materialProperty + ": " + material);
                } else {
                    material = piece["material_" + materialProperty];
                }
                return material;
            }

            function getPieceMaterial2andFollowing(piece, materialProperty) {
                var material;
                if (piece["material_" + materialProperty] != null &&
                    piece["material_" + materialProperty] != "") {
                        materialName = getPieceMaterialParameter(piece, materialProperty);
                        material = getMaterial(materialName).material;
                } else {
                        material = null;
                }
                return material;
            }
            function createMaterialArray(piece, n_materials) {
/*
                var material_1;
                if (piece.material_1.startsWith("parameter:")) {
                    material_1 = eval(piece.material_1.substring(10));  // remove "parameter:" String from value
                    if (console_flag) console.log("material_1: " + material_1);
                } else {
                    material_1 = piece.material_1;
                }
*/
                material_1 = getPieceMaterialParameter(piece, "1");
                if (material_1 == null) {
                    material_1Mat = materialArr[0].material;
                    material_1 = materialArr[0].name;
                } else {
                    material_1Mat = getMaterial(material_1).material;
                }
                if (n_materials == 1) {
                    material_1Mat.previousName = material_1;
                    return material_1Mat;  // in this case there is not array
                }
                meshMaterialArray = [];
                meshMaterialArray.push(material_1Mat);
                for (i = 2; i <= n_materials; i++) {
                    material_Mat = getPieceMaterial2andFollowing(piece, i);
                    if (material_Mat != null) {
                        meshMaterialArray.push(material_Mat);
                    } else {
                        meshMaterialArray.push(meshMaterialArray[meshMaterialArray.length - 1]);  // repeat the last
                    }
                }
                meshMaterialArray.previousName = getMaterialArrayName(piece, meshMaterialArray);
                return meshMaterialArray;
            }
            function setDefaultValues(pieceObj) {
                if (!('sx' in pieceObj)) pieceObj.sx=1;
                if (!('sy' in pieceObj)) pieceObj.sy=1;
                if (!('sz' in pieceObj)) pieceObj.sz=1;
                if (!('rx' in pieceObj)) pieceObj.rx=0;
                if (!('ry' in pieceObj)) pieceObj.ry=0;
                if (!('rz' in pieceObj)) pieceObj.rz=0;
                if (!('x'  in pieceObj)) pieceObj.x=0;
                if (!('y'  in pieceObj)) pieceObj.y=0;
                if (!('z'  in pieceObj)) pieceObj.z=0;
            }
            function prepareACallbackFunctionForLoader(myScene) {
              return function( {scene} ) {
                const object = scene.children[0]
                //object.scale.set(0.2, 0.2, 0.2); 
                //object.visible = false
                  myScene.add(object);
                  updateMeasures();
              } 
              
            }
            function createGroup(THREE) {
/*
                var geometry = new THREE.BufferGeometry();
                const vertices = [];
                vertices.push(new THREE.Vector3( 0, 0, 0));
                var dot = new THREE.Points(geometry, new THREE.PointsMaterial( { color: 0x888888 } ) );

*/
                var dot = new THREE.Group();
                return dot;
            }

</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="w3.css">
<style>
i.fa.fa-caret-down, i.fa.fa-caret-up {
    float: left;
    margin-right: 0.8em;
}

table td.edit i.accIcon.fa.fa-caret-up,
table td.edit i.accIcon.fa.fa-caret-down {
    float: right;
}

#modelDiv .panel, #panel_version.panel {
  padding: 0 18px;
  background-color: white;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
}

li.prepanel {
    list-style-type: none;
    font-size: 1.2em;
    display: flex;
}

#modelDiv span {
    width: 65%;
}

#modelDiv li.active, #modelDiv .panel {
    border: 1px solid lightblue;
}

#modelDiv div.module.property span {
    padding-left: 1em;
    /* padding-right: 0em; */
}

#modelDiv li {
    width: 98%;
}

div.material_option {
    width: 80px;
    height: 80px;
    border-radius: 40px;
    /* background-color: pink; */
    /*border: 5px #e0e0e0 solid; */
    border: 1px #dcdcdc solid;
    display: inline-block;
}

div.material_option span {
    visibility: hidden;
}
div.material_option:hover span {
    visibility: initial;
    background-color: white;
}

div#manufacturer_div {
    display: none;
}
#version {
    display: none;
}
#navbar {
    display: none;
}
</style>


<script>
var selectorQuery = "#modelDiv LI.prepanel";
function createExpandPanels() {
    var acc = document.querySelectorAll(selectorQuery);
    var i;

    for (i = 0; i < acc.length; i++) {
      elem_i = document.createElement("i");
      elem_i.classList.add("accIcon");
      elem_i.classList.add("fa");
      elem_i.classList.add("fa-caret-down");
      //acc[i].appendChild(elem_i);
      acc[i].insertBefore(elem_i, acc[i].firstChild);
      acc[i].addEventListener("click", function () {expandPanel(this);});
    }
}

function expandPanel(elem, finalState) {
    if (finalState != null) {
        if (console_flag) console.log("finalState: " + finalState);
        if (finalState && elem.classList.contains("active")) return;
        if (!finalState && !elem.classList.contains("active")) return;
    }
    elem.classList.toggle("active");
    element_i = elem.querySelector("i.accIcon");
    element_i.classList.toggle("fa-caret-down");
    element_i.classList.toggle("fa-caret-up");
    //var panel = elem.nextElementSibling;
    var panel = document.getElementById("panel_" + elem.id);
    if (panel.style.maxHeight) {
      panel.style.maxHeight = null;
    } else {
      panel.style.maxHeight = panel.scrollHeight + "px";
    } 
}

var expandedAll = false;
function expandAll() {
    expandedAll = !expandedAll;
    var acc = document.querySelectorAll(selectorQuery);
    var i;

    for (i = 0; i < acc.length; i++) {
        expandPanel(acc[i], expandedAll);
    }
}


</script>

<script>
/*
window.onload = start;
function start() {
    var urlSearch = window.location.search.substring(1);
    if (urlSearch == null || urlSearch.length == 0) {
      return;
    }
    ids=urlSearch.split(",");
    var i;
    for (i = 0; i < ids.length; i++) {
        expandPanel(document.getElementById(ids[i]), true)
    }
}
*/

function expand(id) {
  var x = document.getElementById(id);
  if (x.className.indexOf("w3-show") == -1) {
    x.className += " w3-show";
    x.previousElementSibling.className = 
    x.previousElementSibling.className.replace("w3-theme-d1", "w3-theme-d4");
    x.previousElementSibling.className.replace("w3-theme-l4", "w3-theme-l5");
  } else { 
    x.className = x.className.replace(" w3-show", "");
    x.previousElementSibling.className = 
    x.previousElementSibling.className.replace("w3-theme-d4", "w3-theme-d1");
    x.previousElementSibling.className.replace("w3-theme-l5", "w3-theme-l4");
  }
}
</script>

<script>

// tell the embed parent frame the height of the content
if (window.parent && window.parent.parent){
    window.parent.parent.postMessage(["resultsFrame", {
        height: document.body.getBoundingClientRect().height,
        slug: "7u84j6kp"
    }], "*")
}

// always overwrite window.name, in case users try to set it manually
window.name = "result"
</script>



<style>
#modelDiv, #experimentalDiv button {
    margin-left: 2em;
}

div#experimentalDiv {
    display: none;
}

input#collectionName {
    padding: 0px;
    border: 1px solid;
    margin-top: 0.5em;
    padding-left: 1em;
}

#modelDiv h1 a {
    font-size: large;
    margin-left: 1em;
}

#modelDiv .objectLink {
  margin-right: 1em;
}

#modelDiv div#editObject span {
    display: inline-block;
    width: 7em;
    background-color: #bfdfe9;
    margin-right: 1em;
}

input.error {
    background-color: lightsalmon;
}

#modelDiv div#editObject input.property {
    width: 25em;
}

#modelDiv div#editObject  input.property.materialPerpendicular {
    width: 5em;
}

#modelDiv div#editObject span.arrayHeader {
    width: 5em;
    margin-right: 1em;
}
#modelDiv .point {
    width: 5em;
    margin-right: 1em;
}
button#addArrayRow {
    margin-left: 9.6em;
}
#modelDiv table {
    table-layout: fixed;
    width: 100%;
}
#modelDiv table.obj_parameter {
    table-layout: fixed;
}

#modelDiv table.obj_piece {
    margin-bottom: 10px;
}

#modelDiv div#editObject table {
    width: initial;
    margin-left: 4em;
}

#modelDiv td, #modelDiv th {
    /* border: 1px solid blue; */
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
#modelDiv td.new, #modelDiv td.edit {
    width: 7.3em;
    overflow: initial;
    white-space: initial;
    text-overflow: initial;
}
#modelDiv td.new .newSelect{
    width: 7em;
}
td+td {
  width: auto;
}
#modelDiv th:first-of-type {
    color: darkblue;
    width: 8em;
}

#modelDiv div#formArea {
    /* width: 42%; */
    float: left;
}
#renderColumnDiv div#renderArea {
    position: fixed;
}
#none {
    width: 57%;
    min-width: 625px;
    border: 1px blue solid;
    height: 500px;
    float: left;
}
h1, h2 {
    clear: left;
}
    
.controller.function:nth-of-type(1), .controller.function:nth-of-type(2), .controller.function:nth-of-type(3), .controller.function:nth-of-type(4) {
    width: 24%;
    display: inline-block;
}

div#materialPanel {
    position: relative;
    top: -160px;
    width: fit-content;
}

</style>
<style>
.split {
    display: flex;
    flex-direction: row;
}

.gutter {
    background-color: #eee;
    background-repeat: no-repeat;
    background-position: 50%;
}

.gutter.gutter-horizontal {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
    cursor: col-resize;
}
</style>


<li  class="prepanel" id="version" onclick='expandPanel(this);'>Version 79
<i class="accIcon fa fa-caret-down"></i>
</li>
<div class="panel" id="panel_version">
<a href='bezier.html' target=_blank>Bezier curves</a>
<h3>Previous versions</h3>
<br><a href=escene10.html>v 10</a> Include Subsystems
<br><a href=escene11.html>v 11</a> Subsystems with evalText for each subsystem
<br><a href=escene12.html>v 12</a> Arrays
<br><a href=escene13.html>v 13</a> Arrays con limites variables
<br><a href=escene15.html>v 15</a> Remove addDesign and create objects and arrays in updateMeasuresAPI
<br><a href=escene16.html>v 16</a> Change sx, xy, sz to lx, ly, lz
<br><a href=escene17.html>v 17</a> Corregir error de parametro en subsistema - Demo con cajoneras y cajones
<br><a href=escene18.html>v 18</a> Corregir error de parametro en subsistema - Ejemplo armario y 5 cajoneras
<br><a href=escene19.html>v 19</a> Ejemplo armario, para comprobar subsystem
<br><a href=escene19b.html>v 19b</a> Ejemplo armario, para comprobar sin subsystem
<br><a href=escene20b.html>v 20b</a> Corregir evalText para que solo haya un contexto y las variables del nivel (que no se repitan variables)
<br><a href=escene21.html>v 21</a> Pruebas armario
<br><a href=escene22.html>v 22</a> Ejemplo armario
<br><a href=escene23.html>v 23</a> Ejemplo armario con cajon con frontal y fondo
<br><a href=escene24.html>v 24</a> GUI for all objects
<br><a href=escene25.html>v 25</a> Load GLTF objects, forms to edit objects
<br><a href=escene26.html>v 26</a> Forms to edit parameters. Save file
<br><a href=escene27.html>v 27</a> Rotaciones desde el origen. Crear nuevo objeto y cambio de nombre
<br><a href=escene28.html>v 28</a> Rotation ZYX. Glass materials: glass1, glass2
<br><a href=escene29.html>v 29</a> Edición de materiales. BoxGeometry with lx, ly, lz
<br><a href=escene30.html>v 30</a> GLTF objects position. Puerta con rotación
<br><a href=escene31.html>v 31</a> Versión de ejemplo.
<br><a href=escene32.html>v 32</a> Campo type
<br><a href=escene33.html>v 33</a> Textura de cilindros proporcional
<br><a href=escene34.html>v 34</a> Triángulos
<br><a href=escene35.html>v 35</a> Extrusión
<br><a href=escene36.html>v 36</a> Parámetros calculados e internos. Precio.
<br><a href=escene37.html>v 37</a> Formulario de materiales
<br><a href=escene38.html>v 38</a> Pruebas de Environment mapping
<br><a href=escene39.html>v 39</a> Select de options
<br><a href=escene40.html>v 40</a> Editar materiales
<br><a href=escene41.html>v 41</a> Normales en materiales
<br><a href=escene42.html>v 42</a> Esfera
<br><a href=escene43.html>v 43</a> Revolution
<br><a href=escene44.html>v 44</a> Select for type of pieces
<br><a href=escene45.html>v 45</a> Select different options for a piece
<br><a href=escene46.html>v 46</a> 
<br><a href=escene47.html>v 47</a> 3D view with form edit, show errors in alert
<br><a href=escene48.html>v 48</a> Hide objects and materials in design area. Include conditon function to implement if. Parameters for materials
<br><a href=escene49.html>v 49</a> Parameter form open below table of parameters
<br><a href=escene50.html>v 50</a> Botón de representar en fila de LI. Luces
<br><a href=escene51.html>v 51</a> Parameters of modules as parameters of other primitives
<br><a href=escene52.html>v 52</a> Edit modules defined with a parameter (parameter:)
<br><a href=escene53.html>v 53</a> new with types of parameters; order the materials, pieces and parameters
<br><a href=escene54.html>v 54</a> Select of materials. Opción de mostrar entre varios
<br><a href=escene55.html>v 55</a> Restaurar la imagen al inicio al cerrar el editor
<br><a href=escene56.html>v 56</a> En parameters, incluir tipo group y campo array_vector. Mostrar en el interface
<br><a href=escene57.html>v 57</a> Crear un objeto con la estructura en árbol de los parameters POM
<br><a href=escene58.html>v 58</a> Crear el gui a partir del POM. Array de parámetros y ejemplo con cajonera_group y armario con cajones por módulo.
<br><a href=escene59.html>v 59</a> Pasar array a subconjunto. Ejemplo anchura de los módulos del cajón.
<br><a href=escene60.html>v 60</a> Parameters con arrays, inicializar como array.
<br><a href=escene61.html>v 61</a> Utilizar groups que no sean vector en nivel 1. Ejemplo de armario_2
<br><a href=escene62.html>v 62</a> Poder utilizar un parámetros nuevo sin necesidad de representar el objeto. Evitar que de error al cambiar el tipo de módulo en pieces
<br><a href=escene63.html>v 63</a> Que al editar en pieces del tipo subsyste = parameter:, muestre los campos diferentes de todas las opciones
<br><a href=escene64.html>v 64</a> Poder referirse al POM dentro de un group
<br><a href=escene65a.html>v 65a</a> Probar operación booleana
<br><a href=escene66.html>v 66</a> Background and ground
<br><a href=escene67.html>v 67</a> Autosave en edición de pieces
<br><a href=escene68.html>v 68</a> Split en el editor
<br><a href=escene69.html>v 69</a> roughnessMap en materiales
<br><a href=escene70.html>v 70</a> Introducir tamaño y angulo de la textura en parámetros de materiales y aplicar repeatX
<br><a href=escene71.html>v 71</a> Sombras
<br><a href=escene72.html>v 72</a> Sombras en todos los tipos. Angulo de textura en grados
<br><a href=escene73.html>v 73</a> Materiales como parámetros en componentes. Ejemplo en cajones y tapa del armario
<br><a href=escene74.html>v 74</a> No recargar materiales en cada cambio de objeto
<br><a href=escene75.html>v 75</a> Selector de materiales con imágenes, no tener que poner apóstrofe en las opciones de materiales
<br><a href=escene76.html>v 76</a> Opción de textura perpendicular en caras de Box
<br><a href=escene77.html>v 77</a> conditional logging with console - roles
<br><a href=escene78.html>v 78</a> separar env y background; ground y fog. Añadir toneMapping. Añadir Semihesphere con control. Exposure.
<br><a href=escene79.html>v 79</a> objects y materials con id, guardar y recuperar ordenes, guardar imagenes
Movida carpeta build de three/build a build. (de momento copiada) para que tenga la misma estructura que la descarga de three.js original y los ejemplos.
Quitar "materials ext" y opciones de materiales. Cambiar background el checkbox por select de fondos. Intensidad de hemiLight y de lueces punto y direccional. Ver si poner HemisphereLight como tipo de luz en la escena.
<br><a href=escene78.html>v 79</a> Ejemplo de cámara moviéndose en: https://github.com/mrdoob/three.js/blob/master/examples/misc_exporter_gltf.html
Gestión del color: https://threejs.org/docs/#manual/en/introduction/Color-management


  <script>
//document.write("parameters: " + designObj.parameters.length);
//document.write("pieces: " + designObj.pieces.length);
  </script>
</div>

</body></html>
<!-- Tareas
    
V-Quitar Save sin cerrar en Nuevo  
V-Quitar Save sin cerrar en Parámetros y materiales  
V-Editar parámetros debajo de tabla de parámetros

V- Problema en objeto cube, con material: resuelto, cuando no hay default en una opción, se pone la primera
V- Quitar OBJ
V- Actulizar fórmulas (en components)
V- guardar arrays y objects en evalText
V- Actualizar GUI al cambiar array_size
V- Comprobar si debe mantenerse el if de parameter.array_size en evalPOMvalues -> sí, porque uno crea un array del parámetro y el otro un valor
V- Que al reducir un array no se muestren los controles en el gui 1895
V- error en copyMaterialPropertiesFromModelToEditor al moverlo fuera del module

- Parámetro para antialias
- Salvar y cargar los parámetros de un diseño

- comprobar && false  para eliminar function getEvalParameters
- comprobar si hay que hacer eval en: eval(rootParameterObject);

- modulo debe ser un array para evaluarlo
- array_i no definido al evaluar p2
15-08-2021: ver que array_i no se siga acumulando en evalPOMvaluesText

> Comprobar en updatePOMformulas, que coje bien el valor de los parámetros. Pruebas con parámetro p2 en: http://localhost:8082/Configurator/?groups#renderDiv. - probar a actualizar en evalPOMvalues en lugar de updatePOMformulas
Comprobar que el array arrayValues.push(rootParameterObject); se rellena correcto
¿Tiene sentido guardar los índices de los bucles anidados con el nombre del group? En lugar de array_i: modulo_i, bloque_i, ... Pensar si es útil en la evaluación del GUI o/y de las pieces.

Position of: eval("array_i=0;");

Comprobar precisión de condicion cond05 en components


-->
